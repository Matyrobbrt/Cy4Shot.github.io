<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Java Tutorial</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction to Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data_types.html"><strong aria-hidden="true">1.1.</strong> Datatypes</a></li><li class="chapter-item expanded "><a href="syntax.html"><strong aria-hidden="true">1.2.</strong> Syntax</a></li><li class="chapter-item expanded "><a href="operators.html"><strong aria-hidden="true">1.3.</strong> Operators</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">1.4.</strong> Variables</a></li><li class="chapter-item expanded "><a href="control_flow.html"><strong aria-hidden="true">1.5.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="classes.html"><strong aria-hidden="true">1.6.</strong> Classes</a></li><li class="chapter-item expanded "><a href="naming_conventions.html"><strong aria-hidden="true">1.7.</strong> Naming Conventions</a></li><li class="chapter-item expanded "><a href="access_modifiers.html"><strong aria-hidden="true">1.8.</strong> Access Modifiers</a></li><li class="chapter-item expanded "><a href="essential_keywords.html"><strong aria-hidden="true">1.9.</strong> Essential Keywords</a></li><li class="chapter-item expanded "><a href="null_reference.html"><strong aria-hidden="true">1.10.</strong> Null Reference</a></li></ol></li><li class="chapter-item expanded "><a href="advanced.html"><strong aria-hidden="true">2.</strong> More Advanced Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interfaces.html"><strong aria-hidden="true">2.1.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">2.2.</strong> Enums</a></li><li class="chapter-item expanded "><a href="oop.html"><strong aria-hidden="true">2.3.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="solid.html"><strong aria-hidden="true">2.4.</strong> SOLID</a></li><li class="chapter-item expanded "><a href="anonymous_and_abstract.html"><strong aria-hidden="true">2.5.</strong> Anonymous and Abstract Classes</a></li><li class="chapter-item expanded "><a href="lambda.html"><strong aria-hidden="true">2.6.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="method_references.html"><strong aria-hidden="true">2.7.</strong> Method References</a></li><li class="chapter-item expanded "><a href="mutability_immutability.html"><strong aria-hidden="true">2.8.</strong> Mutability and Immutability</a></li><li class="chapter-item expanded "><a href="data_structures.html"><strong aria-hidden="true">2.9.</strong> Data Structures</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">2.10.</strong> Generics</a></li><li class="chapter-item expanded "><a href="exceptions.html"><strong aria-hidden="true">2.11.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="streams.html"><strong aria-hidden="true">2.12.</strong> Streams</a></li><li class="chapter-item expanded "><a href="garbage_collector.html"><strong aria-hidden="true">2.13.</strong> Garbage Collector and Statics</a></li><li class="chapter-item expanded "><a href="concurrency.html"><strong aria-hidden="true">2.14.</strong> Concurrency</a></li></ol></li><li class="chapter-item expanded "><a href="using_apis.html"><strong aria-hidden="true">3.</strong> Using APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="time_apis.html"><strong aria-hidden="true">3.1.</strong> Time APIs</a></li><li class="chapter-item expanded "><a href="java_io.html"><strong aria-hidden="true">3.2.</strong> Java IO</a></li><li class="chapter-item expanded "><a href="java_nio.html"><strong aria-hidden="true">3.3.</strong> Java NIO</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Java Tutorial</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-java"><a class="header" href="#introduction-to-java">Introduction to Java</a></h1>
<p>The first section of this tutorial aims to teach you the basics of Java. By the end of this section of the tutorial you will be able to:</p>
<ul>
<li>Write and understand some basic lines of Java.</li>
<li>Be able to create variables, and use them.</li>
<li>Understand classes, methods and modifiers.</li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before you follow this tutorial, you should:</p>
<ul>
<li>Understand what programming is and what it is used for.</li>
<li>Have Java and an appropriate IDE installed. (<a href="https://www.eclipse.org/">Eclipse</a>, <a href="https://www.jetbrains.com/idea/">IntelliJ</a>, or <a href="https://code.visualstudio.com/docs/languages/java">VSCode</a> is recommended.</li>
</ul>
<h2 id="credits"><a class="header" href="#credits">Credits</a></h2>
<p>This tutorial was written by Temedy, and formatted by Cy4.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="datatypes"><a class="header" href="#datatypes">Datatypes</a></h1>
<p>In the java language, there are two kinds of data types:</p>
<ol>
<li>Primitive data types</li>
<li>Reference data types</li>
</ol>
<h2 id="primitive-data-types"><a class="header" href="#primitive-data-types">Primitive Data Types</a></h2>
<p>Primitive data types include:</p>
<ul>
<li><code>byte</code>, can store values of <code>-128</code> to <code>127</code>  (1 byte)</li>
<li><code>short</code>, can store value of <code>-32768</code> to <code>32767</code> (2 bytes)</li>
<li><code>int</code>, can store value of <code>-2147483648</code> to <code>2147483647</code> (4 bytes)</li>
<li><code>long</code>, can store value of <code>-9223372036854775808</code> to <code>9223372036854775807</code> (8 bytes)</li>
<li><code>char</code>, can store characters (2 bytes)</li>
<li><code>double</code>, can store decimal numbers (8 bytes)</li>
<li><code>float</code>, can store decimal numbers (4 bytes)</li>
<li><code>boolean</code>, can either store <code>true</code> or <code>false</code> (1 byte)</li>
</ul>
<p>The reason why would you use data types such as <code>byte</code> over an <code>int</code> or <code>long</code> is saving memory. When you have simple variables and their value doesn't go larger than 127 there's no reason to use <code>int</code>.</p>
<h2 id="reference-data-types"><a class="header" href="#reference-data-types">Reference Data Types</a></h2>
<p>Reference data types include things such as interfaces, classes, annotations, arrays, interfaces, and so on.</p>
<p><strong>Important notes:</strong></p>
<ul>
<li>Reference data types are objects, while primitive data types aren't.</li>
<li>Primitive data types can not point to <code>null</code> reference while reference data types can.</li>
<li>The value of reference data types defaults to <code>null</code>, however. In the case of primitives, their default value is assigned (the minimum value).</li>
</ul>
<p>Now we will discuss some of the reference types.</p>
<ul>
<li><code>String</code>, which is a class that is <strong>immutable</strong>, is essentially a type for a sequence of characters with a few useful methods. The string can be of any length that must be within the maximum value of an <code>int</code> data type.</li>
<li><code>Array</code>, arrays in java are objects that can be created of any type, regardless if it's a primitive or a reference type. An array is a linear data structure that holds elements. It can have a length that must be within the max value of the data type <code>int</code>. If a value below <code>0</code> is specified, a <code>NegativeArraySizeException</code> is thrown. We will also cover exceptions and all of the other things in the next tutorials.</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="syntax---declaration"><a class="header" href="#syntax---declaration">Syntax - Declaration</a></h1>
<p>First, we will begin with the basic syntax of declarations.
To declare a variable, we simply choose the type of the variable (we will use <code>int</code>) and give it a name.</p>
<pre><code class="language-java">int foo;
</code></pre>
<p>To declare multiple variables with the same type, we can use:</p>
<pre><code class="language-java">int foo, foo1, foo2;
</code></pre>
<p><strong>Important note:</strong>
Every declaration ends with a <code>;</code> character, essentially means &quot;end of command&quot;, a command can be anything such as a method call or a variable declaration. We will discuss it more later.</p>
<p>Now, this style of declaration is also valid for any other data types (reference or primitive)
We can for example also do:</p>
<pre><code class="language-java">String foo;
</code></pre>
<p>and</p>
<pre><code class="language-java">String foo, foo1, foo2;
</code></pre>
<p>Remember that the term <code>value</code> is often only used when working with primitive types, when we are working with reference types, we usually store a <em>reference</em> to a particular object.</p>
<p>The only real difference we need to be careful about when declaring is as I've said before the default value of the variables. If they do not have a value assigned, for reference types it defaults to <code>null</code> reference and for primitive values, it defaults to their minimum value, as said in the section above.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>Operators are actions that let us control our variables inside java. In this chapter I will discuss <strong>5</strong> different types of operators:</p>
<ol>
<li>Assignment Operators</li>
<li>Arithmetic Operators</li>
<li>Unary Operators</li>
<li>Boolean Operators</li>
<li>Bitwise Operators</li>
</ol>
<h2 id="assignment-operators"><a class="header" href="#assignment-operators">Assignment Operators</a></h2>
<p>To assign our variable <code>foo</code> from the previous section a value, we have two ways of doing that.</p>
<p>The first style is:</p>
<pre><code class="language-java">int foo = 1;
</code></pre>
<p>And the other:</p>
<pre><code class="language-java">int foo;
foo = 1;
</code></pre>
<p>The first is doing a declaration &amp; an assignment at the same time, while the other is split into declaration and assignment (we will discuss this later in the section <strong>7</strong> (<em>OOP</em>))</p>
<p>If we are working with primitives, we are assigning those variables a <code>value</code>.
And if we are working with reference types, we are assigning those variables a <code>reference</code>.</p>
<p>We will explain the differences between those two, and on how java handles them.</p>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h2>
<p>These are <strong>five</strong> arithmetic operators available:</p>
<ul>
<li><code>+</code>,  addition</li>
<li><code>-</code>,  subtraction</li>
<li><code>/</code>,  division</li>
<li><code>*</code>, multiplication</li>
<li><code>%</code>, modulo (remainder)</li>
</ul>
<p>Those can be only used while working with primitive types.
The only exception is a <strong>string concatenation</strong>, where we want to put two sequence of characters (string literals) together. The java compiler then uses a class in the JDK called <strong>StringBuilder</strong> and concatenate those strings together.</p>
<p>An example usage of those operators:</p>
<pre><code class="language-java">int foo = 1;
int bar = 2;

int result = foo + bar;
</code></pre>
<p>Also we don't have to declare a those variables called <code>foo</code>, <code>bar</code>.
It can also be written like this</p>
<pre><code class="language-java">int result = 1 + 2;
</code></pre>
<p>Although it doesn't make much sense here to do that, it's just to show how to use these operators. The rest can be used just the same as the addition operator. </p>
<p>Note: We get an <strong>ArithmeticException</strong> when we try to divide by zero.</p>
<h2 id="unary-operators"><a class="header" href="#unary-operators">Unary Operators</a></h2>
<p>Unary Operators are arithmetic operators that only use 1 variable as input data. Here are <strong>5</strong> unary operators:</p>
<ul>
<li><code>+</code> gives a value (or a variable) a positive value </li>
<li><code>-</code> gives a value (or a variable) a negative value</li>
<li><code>++</code> an addition operator that increases a variable value by 1. Can only be performed on variables, and there are two ways of using this operator, we will discuss them.</li>
<li><code>--</code> a subtraction operator that decreases a variable value by 1. can only be performed on variables, just like the <code>++</code> operator.</li>
<li><code>!</code> inverts the value of a boolean (we will see an example of that)</li>
</ul>
<p><em>The</em> <code>+</code><em>,</em> <code>-</code> <em>operators are simply used in value assignment to either give a variable a positive/negative value.</em></p>
<p>Behold this code:</p>
<pre><code class="language-java">int foo = -10;
//foo is now -10
int bar = +10;
//bar is now 10
</code></pre>
<p><em>And the</em> <code>++</code> <em>and</em> <code>--</code> <em>operators can be used as such:</em></p>
<pre><code class="language-java">int foo = 10;
int result = foo++;
</code></pre>
<p>Now to explain, <code>++</code> after a variable reference first gets the original value from <code>foo</code> (which is <code>10</code>) and assigns it to the variable <code>bar</code> and then increments by one.</p>
<p>So in conclusion, <code>foo</code> will be <code>11</code> while <code>result</code> will be <code>10</code>.
The other way it can be used is before a variable reference.</p>
<pre><code class="language-java">int foo = 10;
int result = ++foo;
</code></pre>
<p>To explain the process, first, the variable <code>foo</code> is incremented by one and then assigned to the variable result, so both <code>foo</code> and <code>result</code> will be <code>11</code> here.</p>
<p>Now, the last operator, the boolean invert operator is very simple.
It can only be used on boolean values <code>true</code>, <code>false</code> and all it's self explanatory.
An example of that is:</p>
<pre><code class="language-java">boolean foo = true;
boolean bar = !foo;
</code></pre>
<p>Now, the value of <code>foo</code> will remain <code>true</code>, as the operator doesn't change the value of the original variable (it's not an assignment, so it differs from the last two operators), and the variable <code>bar</code> will have the value <code>false</code>, because we have inverted it. This can obviously be used the other way around aswell (if we start with <code>false</code>).</p>
<h2 id="boolean-operators"><a class="header" href="#boolean-operators">Boolean Operators</a></h2>
<p>Here I will discuss <strong>10</strong> different boolean operators:</p>
<ul>
<li><code>==</code>, compares a value when used on primitive types and a reference when used on reference types</li>
<li><code>&gt;=</code>, is greater than or equal </li>
<li><code>&lt;=</code>, is less than or equal </li>
<li><code>&gt;</code>, is greater than </li>
<li><code>&lt;</code>, is less than</li>
<li><code>!=</code>, an inverted <code>==</code> operator (is not equal to)</li>
<li><code>&amp;&amp;</code>, boolean <em>AND</em>, used to combine many boolean expressions together and check if they <strong>all</strong> return true and returns a boolean value (<code>true</code>, <code>false</code>) depending on that.</li>
<li><code>||</code>, boolean <em>OR</em>, used to combine many boolean expressions together and check if <strong>at least one</strong> of them is true and returns a boolean value (<code>true</code>, <code>false</code>) depending on that.</li>
<li><code>instanceof</code>, used for checking if an <strong>object</strong> is an instance of a particular class or it's subtype.</li>
<li><code>? :</code>, the ternary operator, essentially an inline if statement.</li>
</ul>
<p>What is a boolean expression?
It's a line of code that either returns <code>true</code> or <code>false</code>;
For example:</p>
<pre><code class="language-java">boolean foo = 1 &lt; 2;
</code></pre>
<p><code>1 &lt; 2</code> is the boolean expression here.
The variable <code>foo</code> will now hold the value <code>true</code>.</p>
<p>Another example is:</p>
<pre><code class="language-java">boolean foo = 1 &lt; 2 || 2 &lt; 1;
</code></pre>
<p>The variable <code>foo</code> will now hold the value <code>true</code> again, even though the second expression returns <code>false</code>. That is because its an <code>or</code> operator and the first expression has returned true.
However, this expression:</p>
<pre><code class="language-java">boolean foo = 1 &lt; 2 &amp;&amp; 2 &lt; 1;
</code></pre>
<p>Would hold the value <code>false</code>, because the second expression returned <code>false</code>.</p>
<p>Now, boolean expressions can be used in many places where a boolean is needed. For example an <code>if</code> statement (we will go through those as well).</p>
<pre><code class="language-java">int foo = 5;
int bar = 10;

if (bar &gt; foo) {
   // run some code
}
</code></pre>
<p>As for understanding the <code>instanceof</code> operator, you may have to go through the <strong>object oriented programming</strong> section.
However, here is an example:</p>
<pre><code class="language-java">Object object = new Boolean(Boolean.TRUE);
boolean foo = object instanceof Boolean;
</code></pre>
<p>And the last, <code>?:</code> (the ternary operator) is an inline if and is a boolean expression.
Here is an example:</p>
<pre><code class="language-java">boolean foo = 10 &gt; 5 ? true : false;
</code></pre>
<p>Obviously, this could just be simplified to <code>10 &gt; 5</code> here because it's a simple assignment, but it could be used to assign different values or possibly references to our variables.
Here is how it looks with a regular <code>if</code> statement:</p>
<pre><code class="language-java">boolean foo;
if (10 &gt; 5) {
  foo = true;
} else {
  foo = false;
}
</code></pre>
<p>Here is another example of a ternary operator in action, where the variable <code>foo</code> is set to <code>5</code> or <code>10</code> depending on whether <code>1</code> is larger than <code>2</code>:</p>
<pre><code class="language-java">int foo = 1 &gt; 2 ? 5 : 10;
</code></pre>
<h2 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h2>
<p>Bitwise operators work on any java integer types (<code>long</code>, <code>int</code>, <code>short</code>, <code>char</code> and <code>byte</code>). <strong>6</strong> are shown below:</p>
<ul>
<li><code>&gt;&gt;</code>, unsigned right shift operator, shifts a bit sequence to the right by a specified amount.</li>
<li><code>&lt;&lt;</code>, unsigned left shift operator, shifts a bit sequence to the left by a specified amount.</li>
<li><code>~</code>, bit invert operator, goes through a sequence of bits (for example a <code>byte</code>) and turns every bit to it's opposite value (<code>1</code> to <code>0</code> for example).</li>
<li><code>&amp;</code>, bit <strong>AND</strong>.</li>
<li><code>|</code>, inclusive bit <strong>OR</strong>.</li>
<li><code>^</code>, exclusive bit <strong>OR</strong>.</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>A variable is a labeled container that can contain a single value of it's type.</p>
<p>Variables consist of:</p>
<ol>
<li>Type</li>
<li>Label</li>
<li>Value</li>
</ol>
<p>We've discussed the syntax of variables in the previous sections.</p>
<pre><code class="language-java">int foo = 1;
</code></pre>
<ul>
<li><code>int</code> is the type.</li>
<li><code>foo</code> is the label.</li>
<li><code>1</code> is the value.</li>
</ul>
<p>As we've mentioned before, variables can either be of a reference or primitive type. They both have their default values (or references) when we've only declared them.</p>
<p>In this chapter, we will cover <strong>4</strong> types of variables:</p>
<ul>
<li>Instance Variable</li>
<li>Class Variable</li>
<li>Local Variable</li>
<li>Parameter Variable</li>
</ul>
<h2 id="instance-variables"><a class="header" href="#instance-variables">Instance Variables</a></h2>
<p>Instance variables (fields) are variables that belong to an instance of a particular class. For example, behold a class <code>Car</code>.</p>
<pre><code class="language-java">class Car {
  float speed;
  String make;
}
</code></pre>
<p>We will discuss the syntax of classes in the next section.
The class currently has 2 instance fields (<code>speed</code>, <code>make</code>) which have no value assigned (the <code>speed</code> value defaults to <code>0.0f</code> and the <code>make</code>'s reference defaults to a <code>null</code> reference).</p>
<p>Classes in java inherit from a superclass called <code>Object</code>, which has an empty <strong>constructor</strong> available.
That means we can do:</p>
<pre><code class="language-java">Car car = new Car();
</code></pre>
<p>In order to create our first car. Now to assign values to our fields, we simply do:</p>
<pre><code class="language-java">Car car = new Car();
car.speed = 1f;
car.make = &quot;Ford&quot;;
</code></pre>
<p>Instance variables just mean that they belong to an <strong>instance of a class</strong> (also known as an object, not to be confused with the class <code>Object</code>), they don't represent a global state and are completely instance dependent. We will discuss instances and classes later.</p>
<h2 id="class-variables"><a class="header" href="#class-variables">Class Variables</a></h2>
<p>Class variables, are those which are declared with the <code>static</code> modifier and belong to the class rather than to an instance of the class (object).
A class variable is loaded on a load of a class (since it belongs to the class) instead of an instantiation of a class. Since it represents a global state, it's value will be the same across all instances or static contexts.</p>
<p>A class variable <strong>cannot</strong> be garbage collected, unless it's reference or value is set to <code>null</code> manually, or unless the class it's contained in is unloaded.</p>
<h2 id="local-variables"><a class="header" href="#local-variables">Local Variables</a></h2>
<p>Local variables are those we define in the scope of a function. A scope is simply a region of code, as shown in the example below: </p>
<pre><code class="language-java">class Car {
  float speed;
  String make;

  void drive() {
    speed = 1f;   
  }

  void stop() {
    speed = 0f;
  }
}
</code></pre>
<p>Within the scope of the <code>drive</code> method, we can access all instance variables such as the variable <code>speed</code>.
If we would create a <strong>local variable</strong> inside the method <code>drive</code>, it would be only accessible in the scope of the method, not outside the method.</p>
<pre><code class="language-java">class Car {
  float speed;
  String make;

  void drive() {
    int foo = 1;
    speed = 1f;   
  }

  void stop() {
    foo = 2; //ERROR: undefined variable
    speed = 0f;
  }
}
</code></pre>
<h2 id="parameter-variables"><a class="header" href="#parameter-variables">Parameter Variables</a></h2>
<p>Parameters, are variables that are passed into <strong>functions</strong>. Functions include a <strong>constructor</strong> and a <strong>method</strong>.
Let's modify our last example:</p>
<pre><code class="language-java">class Car {
  float speed;
  String make;

  void drive(float newSpeed) {
    speed = newSpeed;
  }

  void stop() {
    speed = 0f;
  }
}
</code></pre>
<p>One important thing to remember is that, <strong>primitive types are pass-by-value</strong> and <strong>reference types are pass-by-reference</strong>.
This means that if we create an instance of our class <code>Car</code> and call the <code>drive</code> method, we need to pass in a  parameter (a <code>float</code>).</p>
<pre><code class="language-java">Car car = new Car();
car.drive(2f);
</code></pre>
<p>The value will be passed into the method and turnt into a local variable in our scope of <code>drive</code>. If we would predefine a variable called speed and then pass it into the method:</p>
<pre><code class="language-java">Car car = new Car();
float speed = 2f;

car.drive(speed);
</code></pre>
<p>And then change the value inside the method <code>drive</code>, it's value would only be changed in the scope of the method we called. The original variable <code>speed</code> would still have the value <code>2f</code> no matter what.
This is because primitive types are pass by value, so their value gets copied into the method parameter.</p>
<p>To finish the parameter section, reference types are pass-by-reference as we said. We are still not allowed to change the references of objects when they are passed into functions. The only difference is that there is no copy of an object made, the object that was passed into the function is still the same object. This means that we can still change the fields (mutate) the original object, however we are only not allowed to change the reference (again, only in the scope of the method).</p>
<pre><code class="language-java">Car toyota = new Car();

Car ford = new Car(toyota);
</code></pre>
<p>There is a new concept used, which is a <strong>constructor</strong>.</p>
<pre><code class="language-java">class Car {
  float speed;
  String make;

  Car() { //empty 
  }

  Car(Car car) {
    car.speed = 1;
    car.make = &quot;Ford&quot;;
  }

  void drive() {
   // ..
  }
}
</code></pre>
<p>The instance variables (fields) of <code>toyota</code> <strong>will change</strong> to the ones we have defined in the <code>Car</code> constructor (<code>1</code>, <code>Ford</code>), but if we attempt to change the reference of the parameter <code>car</code> to for example a <code>null</code> reference, nothing will change and we will still be able to operate with our original <code>toyota</code>.</p>
<pre><code class="language-java">class Car {
  float speed;
  String make;

  Car() { //empty 
  }

  Car(Car car) {
    car.speed = 1;
    car.make = &quot;Ford&quot;;
    car = null; // this is fine
  }

  void drive() {
   // ..
  }
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Control flows allows us to iterate and make desicions inside our code.</p>
<h2 id="if-statements"><a class="header" href="#if-statements">If Statements</a></h2>
<p>We will begin with if statements. The syntax is the following:</p>
<pre><code class="language-java">if (condition) {
 
}
</code></pre>
<p>First, we begin with the <code>if</code> keyword, then put brackets around and a boolean expression inside the brackets. Then we add a thing called an <strong>if body</strong>, which is just two {} brackets that introduce a scope.</p>
<p>We have used if statements before, they are quite simple.</p>
<pre><code class="language-java">if (true) {
  // code ran when true
} else {
  // code ran when false
}
</code></pre>
<p>With our boolean expressions, we can also apply things such as <code>||</code> or <code>&amp;&amp;</code> when needed, or possibly invert our boolean expression.</p>
<h2 id="for-loops"><a class="header" href="#for-loops">For Loops</a></h2>
<p>The second control flow statement is a for loop which is a bit harder.
Syntax is the following:</p>
<pre><code class="language-java">for (declaration; condition; operation) {

}
</code></pre>
<p>We first declare a variable (such as an <code>int</code>), then a condition and finally an operation.</p>
<p>The simpliest form of a for loop is:</p>
<pre><code class="language-java">for (int counter = 0; counter &lt; 10; counter++) {
  // code here will run 10 times
}
</code></pre>
<p>We first declare an <code>int</code> variable <code>counter</code> and assign it the value <code>0</code>, then we specify a condition (a boolean expression which is <code>counter &lt; 10</code> here), and then we tell the loop what to do when the condition is true. Here, we increment the variable <code>counter</code> by one.</p>
<h2 id="while-loops"><a class="header" href="#while-loops">While Loops</a></h2>
<p>The while loop is also a loop, but it only takes a condition (boolean expression) to run. The loop will run if the condition will be true. Once the expression will return false, the loop will automatically <strong>break</strong>. <strong>break</strong> is also a keyword, that we will discuss soon alongside with the keyword <strong>continue</strong>. Let's see this example of a while loop that will run infinitely.</p>
<pre><code class="language-java">while (true) {
 // ..
}
</code></pre>
<p>The do-while loop is essentially almost the same as the while loop and the syntax is the following:</p>
<pre><code class="language-java">do {
 //code is ran once
} while (false);
</code></pre>
<p>Now, the only difference here is that the code inside the scope of <code>do</code> will run <strong>at least once</strong>, even if the expression in <code>while</code> returns always <code>false</code>.</p>
<h2 id="switch-statements"><a class="header" href="#switch-statements">Switch Statements</a></h2>
<p>Switch is a way how to chain more if statements with the option of breaking. Switch consists of cases and a default (optional).
See this example:</p>
<pre><code class="language-java">int foo = 1;
switch (foo) {
  case 1: {
    // code here is ran
  }
  case 2: {
    // code here is also ran because we have not added a break in the first case
  }
}
</code></pre>
<p>As you can see, if switch meets the correct case, it will keep going through all the other cases below it until it meets a <code>break</code>. 
We can also add a default to the switch to run some code if none of the cases is the value specified.</p>
<p>Note that we can only use enumerations, strings and all primitives in a switch, no other <strong>objects</strong>.</p>
<p>I will explain why is an enumeration and a string possible in a switch later.</p>
<pre><code class="language-java">int foo = 1;
switch (foo) {
  case 1: {
    // code here is ran 
    break;
  }
  case 2: {
    // code here is not ran
  }

  default: {
     // code here is always ran
     break;
  }
}
</code></pre>
<h2 id="break-and-continue-keywords"><a class="header" href="#break-and-continue-keywords">Break and Continue Keywords</a></h2>
<p>As we have seen, the <strong>break</strong> keyword can be used in a loop but also in a switch, however the <strong>continue</strong> keyword can only be used in loops.</p>
<p>The break keyword ends execution of the control flow statement (such as a loop or a switch) and the continue keyword skips 1 iteration in the loop (but not ending it entirely)</p>
<p>We will later discuss the keyword return and how it's similar to the keyword <strong>continue</strong>, it essentially does the same thing but <strong>continue</strong> only returns from the control flow statement, while <strong>return</strong> returns from an entire function.</p>
<pre><code class="language-java">int foo = 0;
while (foo &lt; 10) {
  if (foo &lt;= 5) {
    ++foo;
    continue;
  }

  ++foo;
  // do extra work here
}
</code></pre>
<p>Now, code here will only increment <code>foo</code> by one 6 times and by saying <code>continue</code>, we skip the current execution (iteration) of the control flow statement, so anything after the first if statement doesn't get executed.
If we would use a <strong>break</strong> however, the entire execution of the loop would be terminated.</p>
<pre><code class="language-java">int foo = 0;
while (foo &lt; 10) {
  if (foo &lt;= 5) {
    ++foo;
    break;
  }

  ++foo;
  // do extra work here
}
</code></pre>
<h2 id="chaining-if-statements"><a class="header" href="#chaining-if-statements">Chaining If Statements</a></h2>
<p>In addition to if statements, we can write multiple if statements like this:</p>
<pre><code class="language-java">if (condition) {
 // ..
} else if (condition) {
 // ..
} else if (condition) {
 // ..
} else {
 // ..
}
</code></pre>
<p>Which would run any of the if statements if their condition would be true, but note that the difference between writing them as separate statements is that if one of the if statements is true, the statements after it don't get executed anymore, kinda like a switch with a break in every case.</p>
<p>If none of those conditions would be true however, the <code>else</code> statement would run.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<p>What is a class? Well, a class is essentially a template which contains <strong>members</strong>. We can use this template to create <strong>objects</strong> (instances of that class) as we have with the <code>Car</code> example before.</p>
<p>Members include:</p>
<ol>
<li>Methods</li>
<li>Initialization blocks</li>
<li>Nested classes</li>
<li>Fields</li>
<li>Constructors</li>
</ol>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>To begin explaining, methods belong to a group called functions, alongside with constructors. </p>
<p>Method is a block of code that can accept parameters.
Methods can either be static or instance.</p>
<p>The syntax of methods is:
<code>[modifiers] ReturnType methodName(parameters) { }</code>
So they consist of modifiers, a return type, a method name and can either accept parameters or nothing. They also have a body which introduces another scope. That's where we run our code.
We have met with methods in my <code>Car</code> example, where I had a method called <code>drive</code> that accepted a speed parameter.</p>
<p>Behold a simple method:</p>
<pre><code class="language-java">int multiply(int a, int b) {
  return a * b;
}
</code></pre>
<ol>
<li>There are no modifiers here</li>
<li>The return type is a primitive <code>int</code></li>
<li>The parameters accepted are two primitives, 2 ints called <code>a</code>,<code> b</code></li>
<li>If the method has a return type, it obviously needs to return something. Here it needs to return an int, so we simply get one from multiplying <code>a</code> by <code>b</code>.</li>
</ol>
<p>If we don't want to return a value, we use a special type called <code>void</code>
See this:</p>
<pre><code class="language-java">void print(String text) {
  System.out.println(text);
}
</code></pre>
<ol>
<li>There are no modifiers here</li>
<li>The return type is <code>void</code></li>
<li>It accepts a parameter, a <code>String</code> called <code>text</code></li>
<li>The method doesn't need to return anything as it's a special type <code>void</code>.</li>
</ol>
<p>Now, we are also familiar with the method <code>println</code>, that's how we can print text to a console.</p>
<h2 id="initialization-blocks"><a class="header" href="#initialization-blocks">Initialization Blocks</a></h2>
<p>There are two kinds of initialization blocks.
One is static and the other is instance.</p>
<p>Essentially they are just a block of code. Unlike method, they can't accept parameters, they can't have modifiers (except <code>static</code>) and they can't return a value.
Really just a block of code.</p>
<p>The first version is the <code>static {}</code> initializer, which runs on a <strong>class load</strong> which is an advanced concept that i'll cover later.
See this example:</p>
<pre><code class="language-java">class Foo {
  static {
    System.out.println(&quot;Im printed on class load!&quot;);
  }
}
</code></pre>
<p>Now, when we run our program, all of the classes we have in our project will get loaded. Therefore the text will be printed.</p>
<p>The other version of an initializer is an instance initializer.</p>
<pre><code class="language-java">class Foo {
  {
   System.out.println(&quot;Im printed on an instance creation&quot;);
  }
}
</code></pre>
<p>That text will get printed any time we do:</p>
<pre><code class="language-java">Foo foo = new Foo();
</code></pre>
<p>To explain how it works, the block of code is copied into all existing constructors (here is the 1 empty from <code>Object</code> which is pasted in by the compiler later).</p>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>A constructor is a function (not a method) that is called on an instantiation of a class (on object creation) As i have mentioned earlier, all classes inherit from a superclass called Object. That class contains an empty constructor, so when our code is compiled, the <code>Foo</code> class essentially looks like this:</p>
<pre><code class="language-java">class Foo extends Object {
  Foo() {
    super();
  }
}
</code></pre>
<p>There is also a new keyword, <code>super</code>. <code>super</code> calls the superclass constructor from the superclass we are inheriting from (the empty one in <code>Object</code>).
If we are inheriting from a class, the <code>super</code> statement needs to be first command, otherwise we get an compilation error.
We will discuss why is that later.</p>
<p>Speaking of <code>super</code>, there is also <code>this</code> which can either be used for refering to instance variables, or with a body, it can be used for constructor chaining which is something we will cover soon.</p>
<p>To invoke a constructor, we begin with the keyword <code>new</code> and then specify the class name and the parameters, if there are none (an empty constructors) we simply say <code>()</code> and end the command with <code>;</code>.</p>
<p><code>new Foo();</code> calls the default constructor and returns a new <strong>instance</strong> of a the class <code>Foo</code> (or an object).</p>
<p>The syntax of constructors is the following:
<code>[modifiers] ClassName(params) {}</code></p>
<ol>
<li>The modifiers (visibility for example)</li>
<li>The class name </li>
<li>The parameters just like in a method</li>
<li>The body of the constructor</li>
</ol>
<h2 id="chaining-constructors"><a class="header" href="#chaining-constructors">Chaining Constructors</a></h2>
<p>When we want to have defaults for values, for example, we can use constructor chaining. For example, let's get back to the <code>Car</code> example.</p>
<pre><code class="language-java">class Car {
  float speed;
  String make;

  Car() {
   this(&quot;Toyota&quot;);
  }

  Car(String make) {
    this(1f, make);
  }

  Car(float speed, String make) {
    this.speed = speed;
    this.make = make;
  }
}
</code></pre>
<p>So to analyze this, we now have a <code>Class</code> that has 5 members.
3 constructors and 2 instance variables (we will call them fields from now on)</p>
<p>There are three ways we can initialize our <code>Car</code> class right now, since we have three constructors available:</p>
<pre><code class="language-java">Car first = new Car(); 
Car second = new Car(&quot;Ford&quot;);
Car third = new Car(2f, &quot;Ford&quot;);
</code></pre>
<p>The fields of the object <code>first</code> will be:</p>
<pre><code>speed: 1
make: Toyota`
</code></pre>
<p>The fields of the object <code>second</code> will be:</p>
<pre><code>speed: 1
make: Ford
</code></pre>
<p>The fields of the object <code>third</code> will be:</p>
<pre><code>speed: 2
make: Ford
</code></pre>
<p>With <code>this()</code> we are calling another constructor in the class.</p>
<h2 id="constructor-overloading"><a class="header" href="#constructor-overloading">Constructor Overloading</a></h2>
<p>We can have multiple constructors with different parameters.
In the previous section where we have covered constructor chaining, we also overloaded constructors (we had three) with different parameters.</p>
<p>We can also overload methods.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>Fields are also members and they can be instance or static. We have discussed this before, but with different terms.</p>
<p>With field, we will refer to instance variable (since it belongs to an instance of a class)
With static field, we will refer to class variable (since it belongs to a class)</p>
<p>Fields have the same syntax as variables, but they can have access modifiers specified with them (such as protected, private, public)</p>
<p>All members of a class can have visibility modifiers specified and visibility modifiers is something we will cover soon.</p>
<h2 id="nested-classes"><a class="header" href="#nested-classes">Nested Classes</a></h2>
<p>We can also have nested classes or any other types (interfaces, annotations, enums)</p>
<p>We usually do that to group code together. 
There are two kinds of nested classes.</p>
<ol>
<li>Static classes</li>
<li>Non-static classes.</li>
</ol>
<p>Static nested classes are independent. The class that the nested class is located in is called <strong>enclosing class</strong>.</p>
<p>Non-static nested classes can not be created independently, and need an instance of the enclosing class to be created.</p>
<p>You can not access members of an enclosing class from a static class (since it's independent), however you can access members of an enclosing class from a non-static nested class, since an instance of the enclosing class is required in order to create an instance of the nested class.</p>
<p>See the following example:</p>
<pre><code class="language-java">class Foo {
  int foo = 1;

  static class Bar {
    Bar() {
     System.out.println(foo); //foo is undefined
    }
  }
}
</code></pre>
<p>To create an instance of a static nested class, use the following syntax:</p>
<pre><code class="language-java">Foo.Bar bar = new Foo.Bar();
</code></pre>
<p>This is possible because the nested class is independent.</p>
<p>As for non-static nested classes, see this example:</p>
<pre><code class="language-java">class Foo {
  int foo = 1;

  class Bar {
    Bar() {
     System.out.println(foo); // works
    }
  }
}
</code></pre>
<p>For creation:</p>
<pre><code class="language-java">Foo.Bar bar = new Foo().new Bar();
</code></pre>
<p>This is possible because our nested class depends on our enclosing class (the instance exists within our class <code>Foo</code>).</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h1>
<p>Naming conventions are important for consistency in code.</p>
<h2 id="method-naming"><a class="header" href="#method-naming">Method Naming</a></h2>
<p>Methods are declared with the label <code>lowerCamelCase</code>.
(Each word's first letter is upper except for the first word)</p>
<p>An example:</p>
<pre><code class="language-java">void lowerCamelCase() {
 // run code
}
</code></pre>
<h2 id="class-naming"><a class="header" href="#class-naming">Class Naming</a></h2>
<p>Classes are declared with the label: <code>UpperCamelCase</code>
(Each word's first letter is upper)</p>
<p>An example:</p>
<pre><code class="language-java">class UpperCamelCase {
  void lowerCamelCase() {
   // run code
  }
}
</code></pre>
<h2 id="variable-naming"><a class="header" href="#variable-naming">Variable Naming</a></h2>
<p>Variables are declared with the same label as methods.
An example:</p>
<pre><code class="language-java">int lowerCamelCase = 1;
</code></pre>
<h2 id="constant-naming"><a class="header" href="#constant-naming">Constant Naming</a></h2>
<p>Constants is a concept we will cover soon. Constants are declared with <code>UPPER_SNAKE_CASE</code>.
(All uppercase and an underscore between words.)</p>
<p>An example:</p>
<pre><code class="language-java">class UpperCamelCase {
  static final int UPPER_SNAKE_CASE = 1;
}
</code></pre>
<h2 id="package-naming"><a class="header" href="#package-naming">Package Naming</a></h2>
<p>Packages are all lowercase and a <code>.</code> between words
They usually start with a domain, project name and section.
For example: <code>com.google.guava.collections</code></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h1>
<p>Access modifiers can be applied to class members.</p>
<ul>
<li><code>public</code>, accessible from anywhere</li>
<li><code>private</code>, only accessible within the same class</li>
<li><code>protected</code>, accessible from subclasses, package and the same class</li>
<li><code>no modifier</code>, accessible from the same package and the class</li>
</ul>
<h2 id="public"><a class="header" href="#public">Public</a></h2>
<p>Public just means accessible from anywhere. An example is shown below:</p>
<pre><code class="language-java">public class Foo {
  public int bar = 1;

  public void bar() {
    // bar is accessible here
  }
}
</code></pre>
<p>This will now also be accessible when we create an instance of <code>Foo</code>:</p>
<pre><code class="language-java">Foo foo = new Foo();
foo.bar; //bar is accessible
</code></pre>
<h2 id="private"><a class="header" href="#private">Private</a></h2>
<p>Private means that the member is only accessible from the class we are in. An example is shown below:</p>
<pre><code class="language-java">public class Foo {
  private int bar = 1;

  public void bar() {
    // bar is accessible here
  }
}
</code></pre>
<p>If we create an instance of this class now and attempt to access <code>bar</code>, we will get a compilation error.</p>
<h2 id="protected"><a class="header" href="#protected">Protected</a></h2>
<p>Protected means that the member is accessible in the package we are in, also in the class where it's defined and by the subclasses of the given class. An example is shown below:</p>
<pre><code class="language-java">public class Foo {
  protected int bar = 1;

  protected void bar() {
    // bar is accessible here
  }
}
</code></pre>
<pre><code class="language-java">public class Bar extends Foo {
  Bar() {
    System.out.println(bar); //bar is accessible
    bar(); // method bar is also accessible
  }
}
</code></pre>
<p>As for no modifier (which is what we we used until now), that automatically says only within the same package and the class.
Notice that we cannot apply modifier except <code>public</code> to a class. That is because protected/private enclosing classes don't make sense. However for nested classes it does make sense so there it's applicable.
One important thing to note is that <code>protected</code> is usually not used that often, because it can lead to bad design and violation of the <strong>OCP</strong> principle from <strong>SOLID</strong> which we will discuss right after <strong>OOP</strong>.</p>
<p>Don't confuse <strong>OOP</strong> with <strong>OCP</strong>, <strong>OOP</strong> stands for Object Oriented Programming, while <strong>OCP</strong> stands for Open Closed Principle.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="essential-keywords"><a class="header" href="#essential-keywords">Essential Keywords</a></h1>
<p>In this chapter, I will cover <strong>3</strong> essential keywords:</p>
<ul>
<li>Final</li>
<li>Return</li>
<li>Import</li>
</ul>
<h2 id="final-keyword"><a class="header" href="#final-keyword">Final Keyword</a></h2>
<p>The keyword can be applied to methods, classes, variables.
In each case it does something different.
First, we will discuss what the <strong>final</strong> keyword does when applied to variables.</p>
<p>See this example:</p>
<pre><code class="language-java">final int foo = 1;
</code></pre>
<p>We have declared a variable <code>foo</code> and assigned it the value <code>1</code>.
We also have specified a <strong>final</strong> modifier which says that the value of the variable cannot be changed anymore.</p>
<p>Note that we cannot do this:</p>
<pre><code class="language-java">final int foo;
</code></pre>
<p>Because final variables need to have a value assigned with them as their value cannot be changed.
Generally, there are only two ways how to assign a value/reference to a final variable.</p>
<ol>
<li>constructor</li>
<li>directly</li>
</ol>
<p>If we are dealing with fields, we can use a constructor to assign our fields values/references from a constructor (<em>note that this is only possible for instance variables</em> <strong>(fields)</strong>) because a constructor is an instance member.</p>
<p>For example:</p>
<pre><code class="language-java">public class Car {
  public final String make;
  public final float speed;

  public Car(String make, float speed) {
    this.make = make;
    this.speed = speed;
  }
}
</code></pre>
<p>Here is also a use of a keyword <strong>this</strong>, which we have discussed a bit earlier.</p>
<p>The other way is doing is directly (local variables) but for fields, it prevents us from passing in new properties to our object every time.
We can also sometimes solve this by constructor chaining.</p>
<p>The final keyword can also be applied to classes and methods.
When applied to a class, we are saying that we can't inherit from that class (in other words, extend the class)</p>
<p>See this example:</p>
<pre><code class="language-java">public final class Car {
  public final String make;
  public final float speed;

  public Car(String make, float speed) {
    this.make = make;
    this.speed = speed;
  }
}
</code></pre>
<p>This class above is now <strong>immutable</strong>, which is something we will talk about later.</p>
<pre><code class="language-java">public class BetterCar extends Car {
  // compilation error
}
</code></pre>
<p>And finally, when used on methods, we are saying that we cannot override that method in it's subclass. For example if <code>Car</code> wasn't final and had a non-final method, we could extend <code>Car</code> and <strong>override</strong> that particular method. That is something we will discuss in the object oriented programming section.</p>
<p>And an example again:</p>
<pre><code class="language-java">public class Car {
  public final String make;
  public final float speed;

  public Car(String make, float speed) {
    this.make = make;
    this.speed = speed;
  }
  
  public final void drive() {
    System.out.println(&quot;Driving&quot;);
  }
}
</code></pre>
<pre><code class="language-java">public class FastCar extends Car {
  @Override public void drive() {
    // compile error
  }
}
</code></pre>
<p>The final keyword is a very important keyword which helps us achieve immutability and has very good advantages when multi threading aswell.</p>
<h2 id="return-keyword"><a class="header" href="#return-keyword">Return Keyword</a></h2>
<p>The <strong>return</strong> keyword is something that we've talked about earlier but not used yet.</p>
<p>It can be used in a function, and it usually stops the execution of the function.
A simple example is:</p>
<pre><code class="language-java">void foo(int bar) {
  if (bar &lt; 0) {
    return;
  }

  System.out.println(&quot;Bar is greater or equal to 0&quot;);
}
</code></pre>
<p>When we call this instance function <code>foo</code> and pass in for example <code>-5</code>, the boolean expression will return true and the method will return. So no printing will happen.
It can also be used in a constructor (the same way)</p>
<h2 id="import-keyword"><a class="header" href="#import-keyword">Import Keyword</a></h2>
<p>The <strong>import</strong> keyword, used for importing files (<code>classes</code>, <code>enums</code>, <code>interfaces</code>).</p>
<p>When we want to use a class that we made from a different package than where it is or a class from a library, we have to import it.</p>
<p>The import syntax looks like:</p>
<pre><code class="language-java">import directory.ClassName;
</code></pre>
<p>There is also a static version of importing, which is used for importing static members of a class.
This looks like:</p>
<pre><code class="language-java">class Foo {
  public static final int BAR = 1;
}

import static directory.Foo.BAR;

class Bar {
  Bar() { System.out.println(BAR); }  
}
</code></pre>
<p>We can also use the asterisk <code>*</code> symbol, to say that we are importing every static member in that particular class (including all fields, methods, nested classes, etc..)
The symbol can be used on both normal and static imports.
We will discuss the rest of keywords when we dive into more advanced topics in which they are used (such as <code>volatile</code>, <code>native</code>, <code>finally</code>, <code>transient</code>, <code>throws</code>, <code>try</code>, <code>catch</code>, etc..)</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="null-reference"><a class="header" href="#null-reference">Null Reference</a></h1>
<p>What is a null reference in java?</p>
<p>Well, it's an absence of a reference.
When we're working with reference types (objects) in java, we can assign them the <code>null</code> reference, simply saying nothing. An absence of a reference can be useful at many times, though for beginners it is actually a bit dangerous, as most beginners encounter the famous <code>NullPointerException</code>. A <code>nul</code>l can either be called a pointer or a 
reference.</p>
<p>Only reference types may hold a <code>null</code> <strong>reference</strong>, hence in it's name.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="more-advanced-java"><a class="header" href="#more-advanced-java">More Advanced Java</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="object-oriented-programming"><a class="header" href="#object-oriented-programming">Object Oriented Programming</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="solid"><a class="header" href="#solid">SOLID</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="anonymous-and-abstract-classes"><a class="header" href="#anonymous-and-abstract-classes">Anonymous and Abstract Classes</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="lambda-expressions"><a class="header" href="#lambda-expressions">Lambda Expressions</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="method-references"><a class="header" href="#method-references">Method References</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mutability-and-immutability"><a class="header" href="#mutability-and-immutability">Mutability and Immutability</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="streams"><a class="header" href="#streams">Streams</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="garbage-collector-and-statics"><a class="header" href="#garbage-collector-and-statics">Garbage Collector and Statics</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="using-apis"><a class="header" href="#using-apis">Using APIs</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="time-apis"><a class="header" href="#time-apis">Time APIs</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="java-io"><a class="header" href="#java-io">Java IO</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="java-nio"><a class="header" href="#java-nio">Java NIO</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
