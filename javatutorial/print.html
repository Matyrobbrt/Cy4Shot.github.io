<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Java Tutorial</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction to Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data_types.html"><strong aria-hidden="true">1.1.</strong> Datatypes</a></li><li class="chapter-item expanded "><a href="syntax.html"><strong aria-hidden="true">1.2.</strong> Syntax</a></li><li class="chapter-item expanded "><a href="operators.html"><strong aria-hidden="true">1.3.</strong> Operators</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">1.4.</strong> Variables</a></li><li class="chapter-item expanded "><a href="control_flow.html"><strong aria-hidden="true">1.5.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="classes.html"><strong aria-hidden="true">1.6.</strong> Classes</a></li><li class="chapter-item expanded "><a href="naming_conventions.html"><strong aria-hidden="true">1.7.</strong> Naming Conventions</a></li><li class="chapter-item expanded "><a href="access_modifiers.html"><strong aria-hidden="true">1.8.</strong> Access Modifiers</a></li><li class="chapter-item expanded "><a href="essential_keywords.html"><strong aria-hidden="true">1.9.</strong> Essential Keywords</a></li><li class="chapter-item expanded "><a href="null_reference.html"><strong aria-hidden="true">1.10.</strong> Null Reference</a></li></ol></li><li class="chapter-item expanded "><a href="advanced.html"><strong aria-hidden="true">2.</strong> More Advanced Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interfaces.html"><strong aria-hidden="true">2.1.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">2.2.</strong> Enums</a></li><li class="chapter-item expanded "><a href="oop.html"><strong aria-hidden="true">2.3.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="solid.html"><strong aria-hidden="true">2.4.</strong> SOLID</a></li><li class="chapter-item expanded "><a href="anonymous.html"><strong aria-hidden="true">2.5.</strong> Anonymous Classes</a></li><li class="chapter-item expanded "><a href="abstract.html"><strong aria-hidden="true">2.6.</strong> Abstract Classes</a></li><li class="chapter-item expanded "><a href="lambda.html"><strong aria-hidden="true">2.7.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="method_references.html"><strong aria-hidden="true">2.8.</strong> Method References</a></li><li class="chapter-item expanded "><a href="mutability_immutability.html"><strong aria-hidden="true">2.9.</strong> Mutability and Immutability</a></li><li class="chapter-item expanded "><a href="data_structures.html"><strong aria-hidden="true">2.10.</strong> Data Structures</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">2.11.</strong> Generics</a></li><li class="chapter-item expanded "><a href="exceptions.html"><strong aria-hidden="true">2.12.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="streams.html"><strong aria-hidden="true">2.13.</strong> Streams</a></li><li class="chapter-item expanded "><a href="garbage_collector.html"><strong aria-hidden="true">2.14.</strong> Garbage Collector and Statics</a></li><li class="chapter-item expanded "><a href="concurrency.html"><strong aria-hidden="true">2.15.</strong> Concurrency</a></li></ol></li><li class="chapter-item expanded "><a href="using_apis.html"><strong aria-hidden="true">3.</strong> Using APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="time_apis.html"><strong aria-hidden="true">3.1.</strong> Time APIs</a></li><li class="chapter-item expanded "><a href="java_io.html"><strong aria-hidden="true">3.2.</strong> Java IO</a></li><li class="chapter-item expanded "><a href="java_nio.html"><strong aria-hidden="true">3.3.</strong> Java NIO</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Java Tutorial</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="section-1-introduction-to-java"><a class="header" href="#section-1-introduction-to-java">Section 1: Introduction to Java</a></h1>
<p>The first section of this tutorial aims to teach you the basics of Java. By the end of this section of the tutorial you will be able to:</p>
<ul>
<li>Write and understand some basic lines of Java.</li>
<li>Be able to create variables, and use them.</li>
<li>Understand classes, methods and modifiers.</li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before you follow this tutorial, you should:</p>
<ul>
<li>Understand what programming is and what it is used for.</li>
<li>Have Java and an appropriate IDE installed. (<a href="https://www.eclipse.org/">Eclipse</a>, <a href="https://www.jetbrains.com/idea/">IntelliJ</a>, or <a href="https://code.visualstudio.com/docs/languages/java">VSCode</a> is recommended.</li>
</ul>
<h2 id="credits"><a class="header" href="#credits">Credits</a></h2>
<p>This tutorial was written by Temedy, and formatted by Cy4.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="datatypes"><a class="header" href="#datatypes">Datatypes</a></h1>
<p>In the java language, there are two kinds of data types:</p>
<ol>
<li>Primitive data types</li>
<li>Reference data types</li>
</ol>
<h2 id="primitive-data-types"><a class="header" href="#primitive-data-types">Primitive Data Types</a></h2>
<p>Primitive data types include:</p>
<ul>
<li><code>byte</code>, can store values of <code>-128</code> to <code>127</code>  (1 byte)</li>
<li><code>short</code>, can store values of <code>-32768</code> to <code>32767</code> (2 bytes)</li>
<li><code>int</code>, can store values of <code>-2147483648</code> to <code>2147483647</code> (4 bytes)</li>
<li><code>long</code>, can store values of <code>-9223372036854775808</code> to <code>9223372036854775807</code> (8 bytes)</li>
<li><code>char</code>, can store characters (2 bytes)</li>
<li><code>double</code>, can store decimal numbers (8 bytes)</li>
<li><code>float</code>, can store decimal numbers (4 bytes)</li>
<li><code>boolean</code>, can either store <code>true</code> or <code>false</code> (1 byte)</li>
</ul>
<p>The reason why would you use data types such as <code>byte</code> over an <code>int</code> or <code>long</code> is saving memory. When you have simple variables and their value doesn't go larger than 127 there's no reason to use <code>int</code>.</p>
<h2 id="reference-data-types"><a class="header" href="#reference-data-types">Reference Data Types</a></h2>
<p>Reference data types include things such as interfaces, classes, annotations, arrays, interfaces, and so on.</p>
<p><strong>Important notes:</strong></p>
<ul>
<li>Reference data types are objects, while primitive data types aren't.</li>
<li>Primitive data types cannot point to <code>null</code> reference while reference data types can.</li>
<li>The value of reference data types defaults to <code>null</code>, however. In the case of primitives, their default value is assigned (the minimum value).</li>
</ul>
<p>Now we will discuss some of the reference types.</p>
<ul>
<li><code>String</code>: a class that is <strong>immutable</strong>, is essentially a type for a sequence of characters with a few useful methods. The string can be of any length that must be within the maximum value of an <code>int</code> data type.</li>
<li><code>Array</code>: arrays in java are objects that can be created of any type, regardless if it's a primitive or a reference type. An array is a linear data structure that holds elements. It can have a length that must be within the max value of the data type <code>int</code>. If a value below <code>0</code> is specified, a <code>NegativeArraySizeException</code> is thrown. We will also cover exceptions and all of the other things in the next tutorials.</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="syntax---declaration"><a class="header" href="#syntax---declaration">Syntax - Declaration</a></h1>
<p>First, we will begin with the basic syntax of declarations.
To declare a variable, we simply choose the type of variable (we will use <code>int</code>) and give it a name.</p>
<pre><code class="language-java">int foo;
</code></pre>
<p>To declare multiple variables with the same type, we can use:</p>
<pre><code class="language-java">int foo, foo1, foo2;
</code></pre>
<p><strong>Important note:</strong>
Every declaration ends with a <code>;</code> character, essentially meaning &quot;end of command&quot;, a command can be anything such as a method call or a variable declaration. We will discuss it more later.</p>
<p>Now, this style of declaration is also valid for any other data types (reference or primitive)
We can for example also do:</p>
<pre><code class="language-java">String foo;
</code></pre>
<p>and</p>
<pre><code class="language-java">String foo, foo1, foo2;
</code></pre>
<p>Remember that the term <code>value</code> is often only used when working with primitive types. When working with reference types, we usually store a <em>reference</em> to a particular object.</p>
<p>The only real difference is that we need to be careful about when declaring is as I've said before the default value of the variables. If they do not have a value assigned, for reference types it defaults to <code>null</code> reference and for primitive values it defaults to their minimum value, as said in the section above.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>Operators are actions that let us control our variables inside Java. In this chapter I will discuss <strong>5</strong> different types of operators:</p>
<ol>
<li>Assignment Operators</li>
<li>Arithmetic Operators</li>
<li>Unary Operators</li>
<li>Boolean Operators</li>
<li>Bitwise Operators</li>
</ol>
<h2 id="assignment-operators"><a class="header" href="#assignment-operators">Assignment Operators</a></h2>
<p>To assign our variable <code>foo</code> from the previous section a value, we have two ways of doing that.</p>
<p>The first style is:</p>
<pre><code class="language-java">int foo = 1;
</code></pre>
<p>And the other:</p>
<pre><code class="language-java">int foo;
foo = 1;
</code></pre>
<p>The first is doing a declaration and an assignment at the same time, while the other is split into declaration and assignment (we will discuss this later in the section <strong>7</strong> (<em>OOP</em>))</p>
<p>If we are working with primitives, we are assigning those variables a <code>value</code>.
If we are working with reference types, we are assigning those variables a <code>reference</code>.</p>
<p>I will explain the differences between those two, and how java handles them.</p>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h2>
<p>These are <strong>five</strong> arithmetic operators available:</p>
<ul>
<li><code>+</code>,  addition</li>
<li><code>-</code>,  subtraction</li>
<li><code>/</code>,  division</li>
<li><code>*</code>, multiplication</li>
<li><code>%</code>, modulo (remainder)</li>
</ul>
<p>Those can be only used while working with primitive types.
The only exception is a <strong>string concatenation</strong>, where we want to put two sequence of characters (string literals) together. The java compiler then uses a class in the JDK called <strong>StringBuilder</strong> and concatenates those strings together.</p>
<p>An example usage of those operators:</p>
<pre><code class="language-java">int foo = 1;
int bar = 2;

int result = foo + bar;
</code></pre>
<p>Also we don't have to declare a those variables called <code>foo</code>, <code>bar</code>:
It can also be written like this</p>
<pre><code class="language-java">int result = 1 + 2;
</code></pre>
<p>Although it doesn't make much sense here to do that, it's just to show how to use these operators. The rest can be used just the same as the addition operator. </p>
<p>Note: We get an <strong>ArithmeticException</strong> when we try to divide by zero.</p>
<h2 id="unary-operators"><a class="header" href="#unary-operators">Unary Operators</a></h2>
<p>Unary Operators are arithmetic operators that only use 1 variable as input data. Here are <strong>5</strong> unary operators:</p>
<ul>
<li><code>+</code>: gives a value (or a variable) a positive value </li>
<li><code>-</code>: gives a value (or a variable) a negative value</li>
<li><code>++</code>: an addition operator that increases a variable value by 1. Can only be performed on variables, and there are just two ways of using this operator.</li>
<li><code>--</code>: a subtraction operator that decreases a variable value by 1. Can only be performed on variables, just like the <code>++</code> operator.</li>
<li><code>!</code>: inverts the value of a boolean (we will see an example of that)</li>
</ul>
<p><em>The</em> <code>+</code> <em>and</em> <code>-</code> <em>operators are simply used in value assignment to either give a variable a positive/negative value.</em></p>
<p>Behold this code:</p>
<pre><code class="language-java">int foo = -10;
//foo is now -10
int bar = +10;
//bar is now 10
</code></pre>
<p><em>And the</em> <code>++</code> <em>and</em> <code>--</code> <em>operators can be used as such:</em></p>
<pre><code class="language-java">int foo = 10;
int result = foo++;
</code></pre>
<p>Now to explain, <code>++</code> after a variable reference first gets the original value from <code>foo</code> (which is <code>10</code>) and assigns it to the variable <code>bar</code> and then increments by one.</p>
<p>So in conclusion, <code>foo</code> will be <code>11</code> while <code>result</code> will be <code>10</code>.
The other way it can be used is before a variable reference.</p>
<pre><code class="language-java">int foo = 10;
int result = ++foo;
</code></pre>
<p>To explain the process, first, the variable <code>foo</code> is incremented by one and then assigned to the variable result, so both <code>foo</code> and <code>result</code> will be <code>11</code> here.</p>
<p>Now, the last operator, the boolean invert operator is very simple.
It can only be used on boolean values: <code>true</code> and <code>false</code>.
An example of that is:</p>
<pre><code class="language-java">boolean foo = true;
boolean bar = !foo;
</code></pre>
<p>Now, the value of <code>foo</code> will remain <code>true</code>, as the operator doesn't change the value of the original variable (it's not an assignment, so it differs from the last two operators), and the variable <code>bar</code> will have the value <code>false</code>, because we have inverted it. This can obviously be used the other way around as well, if we start with <code>false</code>.</p>
<h2 id="boolean-operators"><a class="header" href="#boolean-operators">Boolean Operators</a></h2>
<p>Here I will discuss <strong>10</strong> different boolean operators:</p>
<ul>
<li><code>==</code>, compares a value when used on primitive types and a reference when used on reference types.</li>
<li><code>&gt;=</code>, is greater than or equal.</li>
<li><code>&lt;=</code>, is less than or equal.</li>
<li><code>&gt;</code>, is greater than.</li>
<li><code>&lt;</code>, is less than.</li>
<li><code>!=</code>, an inverted <code>==</code> operator (is not equal to).</li>
<li><code>&amp;&amp;</code>, boolean <em>AND</em>, used to combine many boolean expressions together and check if they <strong>all</strong> return true and returns a boolean value (<code>true</code>, <code>false</code>) depending on that.</li>
<li><code>||</code>, boolean <em>OR</em>, used to combine many boolean expressions together and check if <strong>at least one</strong> of them is true and returns a boolean value (<code>true</code>, <code>false</code>) depending on that.</li>
<li><code>instanceof</code>, used for checking if an <strong>object</strong> is an instance of a particular class or it's subtype.</li>
<li><code>? :</code>, the ternary operator, essentially an inline if statement.</li>
</ul>
<p>What is a boolean expression?
It's a line of code that either returns <code>true</code> or <code>false</code>;
For example:</p>
<pre><code class="language-java">boolean foo = 1 &lt; 2;
</code></pre>
<p><code>1 &lt; 2</code> is the boolean expression here.
The variable <code>foo</code> will now hold the value <code>true</code>.</p>
<p>Another example is:</p>
<pre><code class="language-java">boolean foo = 1 &lt; 2 || 2 &lt; 1;
</code></pre>
<p>The variable <code>foo</code> will now hold the value <code>true</code> again, even though the second expression returns <code>false</code>. That is because its an <code>or</code> operator and the first expression has returned true.
However, this expression:</p>
<pre><code class="language-java">boolean foo = 1 &lt; 2 &amp;&amp; 2 &lt; 1;
</code></pre>
<p>Would hold the value <code>false</code>, because the second expression returned <code>false</code>.</p>
<p>Now, boolean expressions can be used in many places where a boolean is needed. For example, an <code>if</code> statement (we will go through those as well).</p>
<pre><code class="language-java">int foo = 5;
int bar = 10;

if (bar &gt; foo) {
   // run some code
}
</code></pre>
<p>As for understanding the <code>instanceof</code> operator, you may have to go through the <strong>object oriented programming</strong> section.
Here is an example:</p>
<pre><code class="language-java">Object object = new Boolean(Boolean.TRUE);
boolean foo = object instanceof Boolean;
</code></pre>
<p>And the last, <code>?:</code> (the ternary operator) is an inline if and is a boolean expression.
Here is an example:</p>
<pre><code class="language-java">boolean foo = 10 &gt; 5 ? true : false;
</code></pre>
<p>Obviously, this could just be simplified to <code>10 &gt; 5</code> here because it's a simple assignment, but it could be used to assign different values or possibly references to our variables.
Here is how it looks with a regular <code>if</code> statement:</p>
<pre><code class="language-java">boolean foo;
if (10 &gt; 5) {
  foo = true;
} else {
  foo = false;
}
</code></pre>
<p>Here is another example of a ternary operator in action, where the variable <code>foo</code> is set to <code>5</code> or <code>10</code> depending on whether <code>1</code> is larger than <code>2</code>:</p>
<pre><code class="language-java">int foo = 1 &gt; 2 ? 5 : 10;
</code></pre>
<h2 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h2>
<p>Bitwise operators work on any java integer types (<code>long</code>, <code>int</code>, <code>short</code>, <code>char</code> and <code>byte</code>). <strong>6</strong> are shown below:</p>
<ul>
<li><code>&gt;&gt;</code>, unsigned right shift operator, shifts a bit sequence to the right by a specified amount.</li>
<li><code>&lt;&lt;</code>, unsigned left shift operator, shifts a bit sequence to the left by a specified amount.</li>
<li><code>~</code>, bit invert operator, goes through a sequence of bits (for example a <code>byte</code>) and turns every bit to it's opposite value (<code>1</code> to <code>0</code> for example).</li>
<li><code>&amp;</code>, bit <strong>AND</strong>.</li>
<li><code>|</code>, inclusive bit <strong>OR</strong>.</li>
<li><code>^</code>, exclusive bit <strong>OR</strong>.</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>A variable is a labelled container that can contain a single value of its type.</p>
<p>Variables consist of:</p>
<ol>
<li>Type</li>
<li>Label</li>
<li>Value</li>
</ol>
<p>We've discussed the syntax of variables in the previous sections:</p>
<pre><code class="language-java">int foo = 1;
</code></pre>
<ul>
<li><code>int</code> is the type.</li>
<li><code>foo</code> is the label.</li>
<li><code>1</code> is the value.</li>
</ul>
<p>As we've mentioned before, variables can either be of a reference or primitive type. They both have their default values (or references) when we've only declared them.</p>
<p>In this chapter, we will cover <strong>4</strong> types of variables:</p>
<ul>
<li>Instance Variable</li>
<li>Class Variable</li>
<li>Local Variable</li>
<li>Parameter Variable</li>
</ul>
<h2 id="instance-variables"><a class="header" href="#instance-variables">Instance Variables</a></h2>
<p>Instance variables (fields) are variables that belong to an instance of a particular class. For example, behold a class <code>Car</code>:</p>
<pre><code class="language-java">class Car {
  float speed;
  String make;
}
</code></pre>
<p>We will discuss the syntax of classes in the next section.
The class currently has 2 instance fields (<code>speed</code>, <code>make</code>) which have no value assigned (the <code>speed</code> value defaults to <code>0.0f</code> and the <code>make</code>'s reference defaults to a <code>null</code> reference).</p>
<p>Classes in java inherit from a superclass called <code>Object</code>, which has an empty <strong>constructor</strong> available.
That means we can do:</p>
<pre><code class="language-java">Car car = new Car();
</code></pre>
<p>In order to create our first car. Now to assign values to our fields, we simply do:</p>
<pre><code class="language-java">Car car = new Car();
car.speed = 1f;
car.make = &quot;Ford&quot;;
</code></pre>
<p>Instance variables just mean that they belong to an <strong>instance of a class</strong> (also known as an object, not to be confused with the class <code>Object</code>); they don't represent a global state and are completely instance dependent. We will discuss instances and classes later.</p>
<h2 id="class-variables"><a class="header" href="#class-variables">Class Variables</a></h2>
<p>Class variables, are those which are declared with the <code>static</code> modifier and belong to the class rather than to an instance of the class (object).
A class variable is loaded on a load of a class (since it belongs to the class) instead of an instantiation of a class. Since it represents a global state, it's value will be the same across all instances or static contexts.</p>
<p>A class variable <strong>cannot</strong> be garbage collected, unless it's reference or value is set to <code>null</code> manually, or unless the class it's contained in is unloaded.</p>
<h2 id="local-variables"><a class="header" href="#local-variables">Local Variables</a></h2>
<p>Local variables are those we define in the scope of a function. A scope is simply a region of code, as shown in the example below: </p>
<pre><code class="language-java">class Car {
  float speed;
  String make;

  void drive() {
    speed = 1f;   
  }

  void stop() {
    speed = 0f;
  }
}
</code></pre>
<p>Within the scope of the <code>drive</code> method, we can access all instance variables such as the variable <code>speed</code>.
If we would create a <strong>local variable</strong> inside the method <code>drive</code>, it would only be accessible in the scope of the method, not outside the method:</p>
<pre><code class="language-java">class Car {
  float speed;
  String make;

  void drive() {
    int foo = 1;
    speed = 1f;   
  }

  void stop() {
    foo = 2; //ERROR: undefined variable
    speed = 0f;
  }
}
</code></pre>
<h2 id="parameter-variables"><a class="header" href="#parameter-variables">Parameter Variables</a></h2>
<p>Parameters are variables that are passed into <strong>functions</strong>. Functions include a <strong>constructor</strong> and a <strong>method</strong>.
Let's modify our last example:</p>
<pre><code class="language-java">class Car {
  float speed;
  String make;

  void drive(float newSpeed) {
    speed = newSpeed;
  }

  void stop() {
    speed = 0f;
  }
}
</code></pre>
<p>One important thing to remember is that <strong>primitive types</strong> are <strong>pass-by-value</strong> and <strong>reference types</strong> are <strong>pass-by-reference</strong>.
This means that if we create an instance of our class <code>Car</code> and call the <code>drive</code> method, we need to pass in a  parameter (a <code>float</code>):</p>
<pre><code class="language-java">Car car = new Car();
car.drive(2f);
</code></pre>
<p>The value will be passed into the method and turned into a local variable in our scope of <code>drive</code>. If we would predefine a variable called speed and then pass it into the method:</p>
<pre><code class="language-java">Car car = new Car();
float speed = 2f;

car.drive(speed);
</code></pre>
<p>And then change the value inside of the method <code>drive</code>, its value would only be changed in the scope of the method we called. The original variable, <code>speed</code>, would still have the value <code>2f</code> no matter what.
This is because primitive types are pass by value, so their value gets copied into the method parameter.</p>
<p>To finish the parameter section, reference types are pass-by-reference as we said. We are still not allowed to change the references of objects when they are passed into functions. The only difference is that there is no copy of an object made, as the object that was passed into the function is still the same object. This means that we can still change the fields of (mutate) the original object, however we aren't allowed to change the reference in the scope of the method.</p>
<pre><code class="language-java">Car toyota = new Car();

Car ford = new Car(toyota);
</code></pre>
<p>There is a new concept used, which is a <strong>constructor</strong>:</p>
<pre><code class="language-java">class Car {
  float speed;
  String make;

  Car() { //empty 
  }

  Car(Car car) {
    car.speed = 1;
    car.make = &quot;Ford&quot;;
  }

  void drive() {
   // ..
  }
}
</code></pre>
<p>The instance variables (fields) of <code>toyota</code> <strong>will change</strong> to the ones we have defined in the <code>Car</code> constructor (<code>1</code>, <code>Ford</code>), but if we attempt to change the reference of the parameter <code>car</code> to, for example, a <code>null</code> reference, nothing will change and we will still be able to operate with our original <code>toyota</code>:</p>
<pre><code class="language-java">class Car {
  float speed;
  String make;

  Car() { //empty 
  }

  Car(Car car) {
    car.speed = 1;
    car.make = &quot;Ford&quot;;
    car = null; // this is fine
  }

  void drive() {
   // ..
  }
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Control flow allows us to iterate and make desicions inside our code.</p>
<h2 id="if-statements"><a class="header" href="#if-statements">If Statements</a></h2>
<p>We will begin with <code>if</code> statements. The syntax is the following:</p>
<pre><code class="language-java">if (condition) {
 
}
</code></pre>
<p>First, we begin with the <code>if</code> keyword, then put brackets around a boolean expression. Then we add something called an <strong>if body</strong>, which is just two <code>{}</code> brackets that introduce a scope.</p>
<p>We have used <code>if</code> statements before, they are quite simple:</p>
<pre><code class="language-java">if (true) {
  // code ran when true
} else {
  // code ran when false
}
</code></pre>
<p>With our boolean expressions, we can also apply things such as <code>||</code> or <code>&amp;&amp;</code> when needed, or possibly invert our boolean expression with an <code>!</code>.</p>
<h2 id="for-loops"><a class="header" href="#for-loops">For Loops</a></h2>
<p>The second control flow statement is a <code>for</code> loop which is a bit harder.
Syntax is the following:</p>
<pre><code class="language-java">for (declaration; condition; operation) {

}
</code></pre>
<p>We first declare a variable (such as an <code>int</code>), then a condition, and finally an operation.</p>
<p>The simpliest form of a <code>for</code> loop is:</p>
<pre><code class="language-java">for (int counter = 0; counter &lt; 10; counter++) {
  // code here will run 10 times
  // counter will range from 0 to 9, each time the code is run
}
</code></pre>
<p>We first declare an <code>int</code> variable <code>counter</code> and assign it the value <code>0</code>, then we specify a condition (a boolean expression which is <code>counter &lt; 10</code> here), and then we tell the loop what to do when the condition is true. Here, we increment the variable <code>counter</code> by one.</p>
<h2 id="while-loops"><a class="header" href="#while-loops">While Loops</a></h2>
<p>The <code>while</code> loop is also a loop, but it only takes a condition (boolean expression) to run. The loop will run if the condition will be true. Once the expression returns <code>false</code>, the loop will automatically <strong>break</strong>. Let's see an example of a <code>while</code> loop that will run infinitely:</p>
<pre><code class="language-java">while (true) {
 // ..
}
</code></pre>
<p>The <code>do-while</code> loop is essentially the same as the <code>while</code> loop. An example of the syntax is shown below:</p>
<pre><code class="language-java">do {
 //code is ran once
} while (false);
</code></pre>
<p>Now, the only difference here is that the code inside the scope of <code>do</code> will run <strong>at least once</strong>, even if the expression in <code>while</code> always returns <code>false</code>.</p>
<h2 id="switch-statements"><a class="header" href="#switch-statements">Switch Statements</a></h2>
<p>Switch is a way how to chain more <code>if</code> statements with the option of breaking. Switch consists of cases and a default (optional).
Behold the code below:</p>
<pre><code class="language-java">int foo = 1;
switch (foo) {
  case 1: {
    // code here is ran
  }
  case 2: {
    // code here is also ran because we have not added a break in the first case
  }
}
</code></pre>
<p>As you can see, if switch meets the correct case, it will keep going through all the other cases below it until it meets a <code>break</code>. 
We can also add a default to the switch to run some code if none of the cases are the value specified.</p>
<p>Note that we can only use enumerations, strings, and all primitives in a switch, no other <strong>objects</strong>.</p>
<p>I will explain why is an enumeration and a string possible in a switch later.</p>
<pre><code class="language-java">int foo = 1;
switch (foo) {
  case 1: {
    // code here is ran 
    break;
  }
  case 2: {
    // code here is not ran
  }

  default: {
     // code here is always ran
     break;
  }
}
</code></pre>
<h2 id="break-and-continue-keywords"><a class="header" href="#break-and-continue-keywords">Break and Continue Keywords</a></h2>
<p>As we have seen, the <strong>break</strong> keyword can be used in a loop and in a <code>switch</code>. However the <strong>continue</strong> keyword can only be used in loops.</p>
<p>The break keyword ends execution of the control flow statement (such as a loop or a switch) and the continue keyword skips 1 iteration in the loop (but not ending it entirely).</p>
<p>We will later discuss the keyword <code>return</code> and how it's similar to the keyword <strong>continue</strong>: it essentially does the same thing but <strong>continue</strong> only returns from the control flow statement, while <strong>return</strong> returns from an entire function.</p>
<pre><code class="language-java">int foo = 0;
while (foo &lt; 10) {
  if (foo &lt;= 5) {
    ++foo;
    continue;
  }

  ++foo;
  // do extra work here
}
</code></pre>
<p>Now, code here will only increment <code>foo</code> by one, 6 times. By calling the <code>continue</code> keyword, we skip the current execution (iteration) of the control flow statement. Anything after the first <code>if</code> statement doesn't get executed.
If we would use a <strong>break</strong> however, the entire execution of the loop would be terminated:</p>
<pre><code class="language-java">int foo = 0;
while (foo &lt; 10) {
  if (foo &lt;= 5) {
    ++foo;
    break;
  }

  ++foo;
  // do extra work here
}
</code></pre>
<h2 id="chaining-if-statements"><a class="header" href="#chaining-if-statements">Chaining If Statements</a></h2>
<p>In addition to <code>if</code> statements, we can write multiple <code>if</code> statements like this:</p>
<pre><code class="language-java">if (condition) {
 // ..
} else if (condition) {
 // ..
} else if (condition) {
 // ..
} else {
 // ..
}
</code></pre>
<p>Which would run any of the <code>if</code> statements if their conditions are true, but note that the difference between writing them as separate statements is that if one of the if statements is true, the statements after it don't get executed anymore, similar to a switch with a break in every case.</p>
<p>If none of those conditions return <code>true</code>, the <code>else</code> statement would run.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<p>What is a class? Well, a class is essentially a template which contains <strong>members</strong>. We can use this template to create <strong>objects</strong> (instances of that class) as we have with the <code>Car</code> example before.</p>
<p>Members include:</p>
<ol>
<li>Methods</li>
<li>Initialization blocks</li>
<li>Nested classes</li>
<li>Fields</li>
<li>Constructors</li>
</ol>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>To begin explaining, methods belong to a group called functions, alongside with constructors. </p>
<p>Method is a block of code that can accept parameters.
Methods can either be static or instance.</p>
<p>The syntax of methods is:
<code>[modifiers] ReturnType methodName(parameters) { }</code>
So they consist of modifiers, a return type, a method name and can either accept parameters or nothing. They also have a body which introduces another scope. That's where we run our code.
We have met with methods in my <code>Car</code> example, where I had a method called <code>drive</code> that accepted a speed parameter.</p>
<p>Behold a simple method:</p>
<pre><code class="language-java">int multiply(int a, int b) {
  return a * b;
}
</code></pre>
<ol>
<li>There are no modifiers here</li>
<li>The return type is a primitive <code>int</code></li>
<li>The parameters accepted are two primitives, 2 ints called <code>a</code>,<code> b</code></li>
<li>If the method has a return type, it obviously needs to return something. Here it needs to return an int, so we simply get one from multiplying <code>a</code> by <code>b</code>.</li>
</ol>
<p>If we don't want to return a value, we use a special type called <code>void</code>
See this:</p>
<pre><code class="language-java">void print(String text) {
  System.out.println(text);
}
</code></pre>
<ol>
<li>There are no modifiers here</li>
<li>The return type is <code>void</code></li>
<li>It accepts a parameter, a <code>String</code> called <code>text</code></li>
<li>The method doesn't need to return anything as it's a special type <code>void</code>.</li>
</ol>
<p>Now, we are also familiar with the method <code>println</code>, that's how we can print text to a console.</p>
<h2 id="initialization-blocks"><a class="header" href="#initialization-blocks">Initialization Blocks</a></h2>
<p>There are two kinds of initialization blocks.
One is static and the other is instance.</p>
<p>Essentially they are just a block of code. Unlike method, they can't accept parameters, they can't have modifiers (except <code>static</code>) and they can't return a value.
Really just a block of code.</p>
<p>The first version is the <code>static {}</code> initializer, which runs on a <strong>class load</strong> which is an advanced concept that i'll cover later.
See this example:</p>
<pre><code class="language-java">class Foo {
  static {
    System.out.println(&quot;Im printed on class load!&quot;);
  }
}
</code></pre>
<p>Now, when we run our program, all of the classes we have in our project will get loaded. Therefore the text will be printed.</p>
<p>The other version of an initializer is an instance initializer.</p>
<pre><code class="language-java">class Foo {
  {
   System.out.println(&quot;Im printed on an instance creation&quot;);
  }
}
</code></pre>
<p>That text will get printed any time we do:</p>
<pre><code class="language-java">Foo foo = new Foo();
</code></pre>
<p>To explain how it works, the block of code is copied into all existing constructors (here is the 1 empty from <code>Object</code> which is pasted in by the compiler later).</p>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>A constructor is a function (not a method) that is called on an instantiation of a class (on object creation) As i have mentioned earlier, all classes inherit from a superclass called Object. That class contains an empty constructor, so when our code is compiled, the <code>Foo</code> class essentially looks like this:</p>
<pre><code class="language-java">class Foo extends Object {
  Foo() {
    super();
  }
}
</code></pre>
<p>There is also a new keyword, <code>super</code>. <code>super</code> calls the superclass constructor from the superclass we are inheriting from (the empty one in <code>Object</code>).
If we are inheriting from a class, the <code>super</code> statement needs to be first command, otherwise we get an compilation error.
We will discuss why is that later.</p>
<p>Speaking of <code>super</code>, there is also <code>this</code> which can either be used for refering to instance variables, or with a body, it can be used for constructor chaining which is something we will cover soon.</p>
<p>To invoke a constructor, we begin with the keyword <code>new</code> and then specify the class name and the parameters, if there are none (an empty constructors) we simply say <code>()</code> and end the command with <code>;</code>.</p>
<p><code>new Foo();</code> calls the default constructor and returns a new <strong>instance</strong> of a the class <code>Foo</code> (or an object).</p>
<p>The syntax of constructors is the following:
<code>[modifiers] ClassName(params) {}</code></p>
<ol>
<li>The modifiers (visibility for example)</li>
<li>The class name </li>
<li>The parameters just like in a method</li>
<li>The body of the constructor</li>
</ol>
<h2 id="chaining-constructors"><a class="header" href="#chaining-constructors">Chaining Constructors</a></h2>
<p>When we want to have defaults for values, for example, we can use constructor chaining. For example, let's get back to the <code>Car</code> example.</p>
<pre><code class="language-java">class Car {
  float speed;
  String make;

  Car() {
   this(&quot;Toyota&quot;);
  }

  Car(String make) {
    this(1f, make);
  }

  Car(float speed, String make) {
    this.speed = speed;
    this.make = make;
  }
}
</code></pre>
<p>So to analyze this, we now have a <code>Class</code> that has 5 members.
3 constructors and 2 instance variables (we will call them fields from now on)</p>
<p>There are three ways we can initialize our <code>Car</code> class right now, since we have three constructors available:</p>
<pre><code class="language-java">Car first = new Car(); 
Car second = new Car(&quot;Ford&quot;);
Car third = new Car(2f, &quot;Ford&quot;);
</code></pre>
<p>The fields of the object <code>first</code> will be:</p>
<pre><code>speed: 1
make: Toyota`
</code></pre>
<p>The fields of the object <code>second</code> will be:</p>
<pre><code>speed: 1
make: Ford
</code></pre>
<p>The fields of the object <code>third</code> will be:</p>
<pre><code>speed: 2
make: Ford
</code></pre>
<p>With <code>this()</code> we are calling another constructor in the class.</p>
<h2 id="constructor-overloading"><a class="header" href="#constructor-overloading">Constructor Overloading</a></h2>
<p>We can have multiple constructors with different parameters.
In the previous section where we have covered constructor chaining, we also overloaded constructors (we had three) with different parameters.</p>
<p>We can also overload methods.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>Fields are also members and they can be instance or static. We have discussed this before, but with different terms.</p>
<p>With field, we will refer to instance variable (since it belongs to an instance of a class)
With static field, we will refer to class variable (since it belongs to a class)</p>
<p>Fields have the same syntax as variables, but they can have access modifiers specified with them (such as protected, private, public)</p>
<p>All members of a class can have visibility modifiers specified and visibility modifiers is something we will cover soon.</p>
<h2 id="nested-classes"><a class="header" href="#nested-classes">Nested Classes</a></h2>
<p>We can also have nested classes or any other types (interfaces, annotations, enums)</p>
<p>We usually do that to group code together. 
There are two kinds of nested classes.</p>
<ol>
<li>Static classes</li>
<li>Non-static classes.</li>
</ol>
<p>Static nested classes are independent. The class that the nested class is located in is called <strong>enclosing class</strong>.</p>
<p>Non-static nested classes can not be created independently, and need an instance of the enclosing class to be created.</p>
<p>You can not access members of an enclosing class from a static class (since it's independent), however you can access members of an enclosing class from a non-static nested class, since an instance of the enclosing class is required in order to create an instance of the nested class.</p>
<p>See the following example:</p>
<pre><code class="language-java">class Foo {
  int foo = 1;

  static class Bar {
    Bar() {
     System.out.println(foo); //foo is undefined
    }
  }
}
</code></pre>
<p>To create an instance of a static nested class, use the following syntax:</p>
<pre><code class="language-java">Foo.Bar bar = new Foo.Bar();
</code></pre>
<p>This is possible because the nested class is independent.</p>
<p>As for non-static nested classes, see this example:</p>
<pre><code class="language-java">class Foo {
  int foo = 1;

  class Bar {
    Bar() {
     System.out.println(foo); // works
    }
  }
}
</code></pre>
<p>For creation:</p>
<pre><code class="language-java">Foo.Bar bar = new Foo().new Bar();
</code></pre>
<p>This is possible because our nested class depends on our enclosing class (the instance exists within our class <code>Foo</code>).</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h1>
<p>Naming conventions are important for consistency in code.</p>
<h2 id="method-naming"><a class="header" href="#method-naming">Method Naming</a></h2>
<p>Methods are declared with the label <code>lowerCamelCase</code>.
(Each word's first letter is upper except for the first word)</p>
<p>An example:</p>
<pre><code class="language-java">void lowerCamelCase() {
 // run code
}
</code></pre>
<h2 id="class-naming"><a class="header" href="#class-naming">Class Naming</a></h2>
<p>Classes are declared with the label: <code>UpperCamelCase</code>
(Each word's first letter is upper)</p>
<p>An example:</p>
<pre><code class="language-java">class UpperCamelCase {
  void lowerCamelCase() {
   // run code
  }
}
</code></pre>
<h2 id="variable-naming"><a class="header" href="#variable-naming">Variable Naming</a></h2>
<p>Variables are declared with the same label as methods.
An example:</p>
<pre><code class="language-java">int lowerCamelCase = 1;
</code></pre>
<h2 id="constant-naming"><a class="header" href="#constant-naming">Constant Naming</a></h2>
<p>Constants is a concept we will cover soon. Constants are declared with <code>UPPER_SNAKE_CASE</code>.
(All uppercase and an underscore between words.)</p>
<p>An example:</p>
<pre><code class="language-java">class UpperCamelCase {
  static final int UPPER_SNAKE_CASE = 1;
}
</code></pre>
<h2 id="package-naming"><a class="header" href="#package-naming">Package Naming</a></h2>
<p>Packages are all lowercase and a <code>.</code> between words
They usually start with a domain, project name and section.
For example: <code>com.google.guava.collections</code></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h1>
<p>Access modifiers can be applied to class members.</p>
<ul>
<li><code>public</code>, accessible from anywhere</li>
<li><code>private</code>, only accessible within the same class</li>
<li><code>protected</code>, accessible from subclasses, package and the same class</li>
<li><code>no modifier</code>, accessible from the same package and the class</li>
</ul>
<h2 id="public"><a class="header" href="#public">Public</a></h2>
<p>Public just means accessible from anywhere. An example is shown below:</p>
<pre><code class="language-java">public class Foo {
  public int bar = 1;

  public void bar() {
    // bar is accessible here
  }
}
</code></pre>
<p>This will now also be accessible when we create an instance of <code>Foo</code>:</p>
<pre><code class="language-java">Foo foo = new Foo();
foo.bar; //bar is accessible
</code></pre>
<h2 id="private"><a class="header" href="#private">Private</a></h2>
<p>Private means that the member is only accessible from the class we are in. An example is shown below:</p>
<pre><code class="language-java">public class Foo {
  private int bar = 1;

  public void bar() {
    // bar is accessible here
  }
}
</code></pre>
<p>If we create an instance of this class now and attempt to access <code>bar</code>, we will get a compilation error.</p>
<h2 id="protected"><a class="header" href="#protected">Protected</a></h2>
<p>Protected means that the member is accessible in the package we are in, also in the class where it's defined and by the subclasses of the given class. An example is shown below:</p>
<pre><code class="language-java">public class Foo {
  protected int bar = 1;

  protected void bar() {
    // bar is accessible here
  }
}
</code></pre>
<pre><code class="language-java">public class Bar extends Foo {
  Bar() {
    System.out.println(bar); //bar is accessible
    bar(); // method bar is also accessible
  }
}
</code></pre>
<p>As for no modifier (which is what we we used until now), that automatically says only within the same package and the class.
Notice that we cannot apply modifier except <code>public</code> to a class. That is because protected/private enclosing classes don't make sense. However for nested classes it does make sense so there it's applicable.
One important thing to note is that <code>protected</code> is usually not used that often, because it can lead to bad design and violation of the <strong>OCP</strong> principle from <strong>SOLID</strong> which we will discuss right after <strong>OOP</strong>.</p>
<p>Don't confuse <strong>OOP</strong> with <strong>OCP</strong>, <strong>OOP</strong> stands for Object Oriented Programming, while <strong>OCP</strong> stands for Open Closed Principle.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="essential-keywords"><a class="header" href="#essential-keywords">Essential Keywords</a></h1>
<p>In this chapter, I will cover <strong>3</strong> essential keywords:</p>
<ul>
<li>Final</li>
<li>Return</li>
<li>Import</li>
</ul>
<h2 id="final-keyword"><a class="header" href="#final-keyword">Final Keyword</a></h2>
<p>The keyword can be applied to methods, classes, variables.
In each case it does something different.
First, we will discuss what the <strong>final</strong> keyword does when applied to variables.</p>
<p>See this example:</p>
<pre><code class="language-java">final int foo = 1;
</code></pre>
<p>We have declared a variable <code>foo</code> and assigned it the value <code>1</code>.
We also have specified a <strong>final</strong> modifier which says that the value of the variable cannot be changed anymore.</p>
<p>Note that we cannot do this:</p>
<pre><code class="language-java">final int foo;
</code></pre>
<p>Because final variables need to have a value assigned with them as their value cannot be changed.
Generally, there are only two ways how to assign a value/reference to a final variable.</p>
<ol>
<li>constructor</li>
<li>directly</li>
</ol>
<p>If we are dealing with fields, we can use a constructor to assign our fields values/references from a constructor (<em>note that this is only possible for instance variables</em> <strong>(fields)</strong>) because a constructor is an instance member.</p>
<p>For example:</p>
<pre><code class="language-java">public class Car {
  public final String make;
  public final float speed;

  public Car(String make, float speed) {
    this.make = make;
    this.speed = speed;
  }
}
</code></pre>
<p>Here is also a use of a keyword <strong>this</strong>, which we have discussed a bit earlier.</p>
<p>The other way is doing is directly (local variables) but for fields, it prevents us from passing in new properties to our object every time.
We can also sometimes solve this by constructor chaining.</p>
<p>The final keyword can also be applied to classes and methods.
When applied to a class, we are saying that we can't inherit from that class (in other words, extend the class)</p>
<p>See this example:</p>
<pre><code class="language-java">public final class Car {
  public final String make;
  public final float speed;

  public Car(String make, float speed) {
    this.make = make;
    this.speed = speed;
  }
}
</code></pre>
<p>This class above is now <strong>immutable</strong>, which is something we will talk about later.</p>
<pre><code class="language-java">public class BetterCar extends Car {
  // compilation error
}
</code></pre>
<p>And finally, when used on methods, we are saying that we cannot override that method in it's subclass. For example if <code>Car</code> wasn't final and had a non-final method, we could extend <code>Car</code> and <strong>override</strong> that particular method. That is something we will discuss in the object oriented programming section.</p>
<p>And an example again:</p>
<pre><code class="language-java">public class Car {
  public final String make;
  public final float speed;

  public Car(String make, float speed) {
    this.make = make;
    this.speed = speed;
  }
  
  public final void drive() {
    System.out.println(&quot;Driving&quot;);
  }
}
</code></pre>
<pre><code class="language-java">public class FastCar extends Car {
  @Override public void drive() {
    // compile error
  }
}
</code></pre>
<p>The final keyword is a very important keyword which helps us achieve immutability and has very good advantages when multi threading aswell.</p>
<h2 id="return-keyword"><a class="header" href="#return-keyword">Return Keyword</a></h2>
<p>The <strong>return</strong> keyword is something that we've talked about earlier but not used yet.</p>
<p>It can be used in a function, and it usually stops the execution of the function.
A simple example is:</p>
<pre><code class="language-java">void foo(int bar) {
  if (bar &lt; 0) {
    return;
  }

  System.out.println(&quot;Bar is greater or equal to 0&quot;);
}
</code></pre>
<p>When we call this instance function <code>foo</code> and pass in for example <code>-5</code>, the boolean expression will return true and the method will return. So no printing will happen.
It can also be used in a constructor (the same way)</p>
<h2 id="import-keyword"><a class="header" href="#import-keyword">Import Keyword</a></h2>
<p>The <strong>import</strong> keyword, used for importing files (<code>classes</code>, <code>enums</code>, <code>interfaces</code>).</p>
<p>When we want to use a class that we made from a different package than where it is or a class from a library, we have to import it.</p>
<p>The import syntax looks like:</p>
<pre><code class="language-java">import directory.ClassName;
</code></pre>
<p>There is also a static version of importing, which is used for importing static members of a class.
This looks like:</p>
<pre><code class="language-java">class Foo {
  public static final int BAR = 1;
}

import static directory.Foo.BAR;

class Bar {
  Bar() { System.out.println(BAR); }  
}
</code></pre>
<p>We can also use the asterisk <code>*</code> symbol, to say that we are importing every static member in that particular class (including all fields, methods, nested classes, etc..)
The symbol can be used on both normal and static imports.
We will discuss the rest of keywords when we dive into more advanced topics in which they are used (such as <code>volatile</code>, <code>native</code>, <code>finally</code>, <code>transient</code>, <code>throws</code>, <code>try</code>, <code>catch</code>, etc..)</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="null-reference"><a class="header" href="#null-reference">Null Reference</a></h1>
<p>What is a null reference in java?</p>
<p>Well, it's an absence of a reference.
When we're working with reference types (objects) in java, we can assign them the <code>null</code> reference, simply saying nothing. An absence of a reference can be useful at many times, though for beginners it is actually a bit dangerous, as most beginners encounter the famous <code>NullPointerException</code>. A <code>nul</code>l can either be called a pointer or a 
reference.</p>
<p>Only reference types may hold a <code>null</code> <strong>reference</strong>, hence in it's name.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="section-2-more-advanced-java"><a class="header" href="#section-2-more-advanced-java">Section 2: More Advanced Java</a></h1>
<p>This section of the book will teach you some more advanced constructs of java, including:</p>
<ul>
<li>Interfaces, Enums, Abstract and Anonymous classes</li>
<li>Object Oriented Programming and Solid</li>
<li>Lamda Expressions. Method Referenced, and Immutability</li>
<li>Data Structures and Generics</li>
<li>Exceptions</li>
<li>Streams, Garbage Collectors and Concurrency</li>
</ul>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before starting this section, it is reccomended that you complete the <code>Introduction to Java</code> section beforehand.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h1>
<p>An interface in java is a way to achieve <strong>abstraction</strong>. Abstraction means to simplify some code, in order to make it easier to implement.
The first way of achieving abstraction is using <strong>abstract classes</strong> which is something we will cover later.</p>
<p>It's also a way of java's dealing with multiple inheritance. Interfaces can only hold two type of members:</p>
<ol>
<li>Constants</li>
<li>Methods</li>
</ol>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>At the top of our interface, we can define any constant like we would in a class:</p>
<pre><code class="language-java">interface Example {
  int x = 5;
  public void run();
}
</code></pre>
<h2 id="methods-1"><a class="header" href="#methods-1">Methods</a></h2>
<p>For methods, there are multiple types of methods it can have.
One type is a <code>default</code>, which is also a keyword in java (we used it in a switch), but it can also be used in an interface to specify an instance method with a body.</p>
<p>Interfaces can also have static methods, just like classes can. <strong>Some</strong> visibility modifiers are also allowed for static and default methods.</p>
<p>And finally, the last type of methods it can have are regular instance methods <strong>without a body</strong>. The body is implemented in an implementation of the interface.</p>
<p>See the following interface:</p>
<pre><code class="language-java">interface Animal {
  void makeSound();

  void move();

  void sleep();

  String getName();
  
  default void print() {
    System.out.println(getName());
  }
}
</code></pre>
<h2 id="use-of-interfaces"><a class="header" href="#use-of-interfaces">Use of interfaces</a></h2>
<p>Interfaces can only be implemented in enumerations and classes. When making an implementation in a class, we use the <code>implements</code> keyword. When implementing an interface in an interface, we use the <code>extends</code> keyword.</p>
<p>An example is shown below:</p>
<pre><code class="language-java">class Koala implements Animal {
  @Override public void makeSound() {
    System.out.println(&quot;null&quot;);
  }

  @Override public void move() {
    System.out.println(&quot;moving&quot;);
  }

  @Override public void sleep() {
    System.out.println(&quot;zzz&quot;);
  }
  @Override public String getName() {
    return &quot;Koala&quot;;
  }
}
</code></pre>
<p>Now, we can use the <code>Animal</code> interface as an abstract object when programming. We can pass animals into methods and make sounds on an request, which will be different on every implementation we have made.</p>
<p>The syntax to create an instance of this class would be:</p>
<pre><code class="language-java">final Animal koala = new Koala();
</code></pre>
<p>However note that we can not do the following:</p>
<pre><code class="language-java">final Animal animal = new Animal();
</code></pre>
<p>That is because Animal is abstract and we can only inherit from it.
One way would be using anonymous classes and the other is regular implementations.
We will discuss anonymous classes later.</p>
<p>This syntax is obviously also valid, but not recommended for many reasons:</p>
<pre><code class="language-java">final Koala koala = new Koala();
</code></pre>
<p>We can also use the default instance method we have made.</p>
<pre><code class="language-java">final Animal koala = new Koala();
koala.print(); // Prints: &quot;Koala&quot;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>An enum is basically a set of specified options that do not change, for example a season in a game.</p>
<p>An enum should be <strong>immutable</strong>.
However, enums should be used rarely, as they can often violate the <strong>OCP</strong> - Open Closed Principle.</p>
<pre><code class="language-java">enum Season {
  SPRING(15, 20F),
  WINTER(20, -50F);
 
  public final int days;
  public final float temperature;

  Season(int days, float temperature) {
    this.days = days;
    this.temperature = temperature;
  }
}
</code></pre>
<p>The syntax is pretty straightforward.
We first declare our fields which <em>should</em> be <code>final</code> and then a constructor for our fields.</p>
<p>Currently, there are 2 instances of <code>Season</code>.</p>
<p>An enum is an object, and every enum constant represents an instance of that particular enum. Enums have special methods, such as static methods like <code>valueOf</code> or <code>values</code>, which allow us to get a enum constant from it's defined label or the array of our enum constants (seasons here).</p>
<p>If we would convert the enum to a class, it would look like this:</p>
<pre><code class="language-java">final class Season {
  public static final Season SPRING = new Season(15, 20F);
  public static final Season WINTER = new Season(20, -50F);
 
  public final int days;
  public final float temperature;

  Season(int days, float temperature) {
    this.days = days;
    this.temperature = temperature;
  }
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="object-oriented-programming-oop"><a class="header" href="#object-oriented-programming-oop">Object Oriented Programming (OOP)</a></h1>
<p>To get started with object oriented programming, we will need to understand what an object and an instance is.</p>
<ul>
<li><code>object</code>s are  simply an instance of a class. (However, <code>Object</code> will usually refer to the superclass of all classes).</li>
<li>An <code>instance</code> is a copy of a class (a template) that is physical.</li>
</ul>
<h3 id="understanding-oop"><a class="header" href="#understanding-oop">Understanding Oop</a></h3>
<p>Think of a game, when we have entities in our game for example, we have a class called <code>Entity</code>, which is the template for our entities that has some fields and methods.</p>
<p>Now, an <strong>instance</strong> of the class <code>Entity</code> (an object) represents a real entity in a world for example. So if we have 5 instances of Entity, we have 5 real entities with each having their own properties, such as a location, world, health, etc..</p>
<p>Inheritance is a concept that allows inherit functionality of certain types (to inherit from a foundation) such as the <code>Animal</code> interface).</p>
<p>Polymorphism is a way of having different behaviours per an implementation, such as the <code>Animal</code> interface we've made before. Every animal makes a sound (they share the same functionality), but every animal makes a different sound.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="solid"><a class="header" href="#solid">SOLID</a></h1>
<p>SOLID is an acronym for five design principles, used in <strong>Object Oriented Programming</strong>:</p>
<ul>
<li><strong>S</strong> - Single Responsibility Principle</li>
<li><strong>O</strong> - Open Closed Principle</li>
<li><strong>L</strong> - Liskov Substitution Principle</li>
<li><strong>I</strong> - Interface Segregation Principle</li>
<li><strong>D</strong> - Dependency Inversion Principle</li>
</ul>
<h2 id="single-responsibility-principle-srp"><a class="header" href="#single-responsibility-principle-srp">Single Responsibility Principle (SRP)</a></h2>
<p>This principle says that a class should only be responsible for one thing. Imagine a <code>Game</code> class which has the methods <code>movePlayer</code>, <code>drawText</code>:</p>
<pre><code class="language-java">class Game {
  void movePlayer(int x, int y) {
    // ..
  }

  void drawText(Screen screen, String text) {
    // ..
  }
}
</code></pre>
<p>This now violates the *<em>SRP</em> principle, because the <code>Game</code> class is currently responsible for two things:</p>
<ul>
<li>Moving the player</li>
<li>Drawing text to screen</li>
</ul>
<p>A fix to that would be removing the methods from the class and working out what a <code>Game</code> class is really responsible for. For example, there could be a <code>Renderer</code> class responsible for rendering text.</p>
<h2 id="open-closed-principle-ocp"><a class="header" href="#open-closed-principle-ocp">Open Closed Principle (OCP)</a></h2>
<p>We have mentioned this principle earlier when explaining enumerations.
This principle says: &quot;Software entities should be open to extension but closed for modification.&quot;</p>
<p>See a following example:</p>
<pre><code class="language-java">void processEntity(Entity entity) {
  switch (entity.type) {
    case PLAYER: {
      break;
    }
    case SPIDER: {
      break;
    }
  }
}
</code></pre>
<p>Let's say that an entity has a <code>type</code> field which is an enum.
This now violate the <strong>OCP</strong> principle, because whenever we add a new entity, we have to go back to our processor, and modify the method to contain the new entity type as well.
One of many fixes would be putting some of the behaviour or required information right into the entity class.</p>
<p>Enums are not always useful for exactly this reason, they cannot be easily addede to.</p>
<h2 id="liskov-substitution-principle-lsp"><a class="header" href="#liskov-substitution-principle-lsp">Liskov Substitution Principle (LSP)</a></h2>
<p>We have mentioned this principle when working with abstract types. What this principle says is: &quot;If a type S is a subtype of T, we should be able to replace S with any subtypes of T without any problems.&quot;
This may sound confusing at first but it is very easy.</p>
<p>Lets go back to our animal interface.</p>
<pre><code class="language-java">interface Animal {
  void makeSound();

  void move();

  void sleep();

  String getName();
  
  default void print() {
    System.out.println(getName());
  }
}
</code></pre>
<p>If we make 2 implementations now,</p>
<pre><code class="language-java">class Koala implements Animal {
  @Override public void makeSound() {
    System.out.println(&quot;null&quot;);
  }

  @Override public void move() {
    System.out.println(&quot;moving&quot;);
  }

  @Override public void sleep() {
    System.out.println(&quot;zzz&quot;);
  }
  @Override public String getName() {
    return &quot;Koala&quot;;
  }
}
</code></pre>
<p>and</p>
<pre><code class="language-java">class Dog implements Animal {
  @Override public void makeSound() {
    System.out.println(&quot;woof&quot;);
  }

  @Override public void move() {
    System.out.println(&quot;moving&quot;);
  }

  @Override public void sleep() {
    System.out.println(&quot;zzz&quot;);
  }
  @Override public String getName() {
    return &quot;Dog&quot;;
  }
}
</code></pre>
<p>And we use Koala as our variable type:</p>
<pre><code class="language-java">Koala animal = new Koala();
animal.print();
</code></pre>
<p>Now, if we would want to change the reference of our <code>koala</code> object to a different implementation (such as the <code>Dog</code>) it wouldn't be allowed, since we've said that the type of the variable is <code>Koala</code>, not an <code>Animal</code>.</p>
<p>An example where it makes sense is when working with collections (which we will cover later).
We have 2 common implementations of the interface <code>List&lt;E&gt;</code>.</p>
<ul>
<li><code>LinkedList</code></li>
<li><code>ArrayList</code></li>
</ul>
<p>If we later want to change our array list to a linked list or the other way around and we have specified <code>LinkedList</code> as the variable type, we cannot.
This violates the <strong>LSP</strong> (Liskov Substitution Principle)</p>
<h2 id="interface-segregation-principle-isp"><a class="header" href="#interface-segregation-principle-isp">Interface Segregation Principle (ISP)</a></h2>
<p>This one is very simple, it just says: &quot;No client should be forced into implementing methods it does not need.&quot;</p>
<p>Say that we have our Animal interface:</p>
<pre><code class="language-java">interface Animal {
  void makeSound();

  void move();

  void sleep();

  String getName();
  
  default void print() {
    System.out.println(getName());
  }
}
</code></pre>
<p>Now, let's say that we want to make a <code>Worm</code> class which implements this interface.</p>
<pre><code class="language-java">class Worm implements Animal {
  @Override public void makeSound() {
    throw new IllegalStateException(&quot;I cannot make sound&quot;);
  }

  @Override public void move() {
    System.out.println(&quot;moving&quot;);
  }

  @Override public void sleep() {
    System.out.println(&quot;zzz&quot;);
  }
  @Override public String getName() {
    return &quot;Worm&quot;;
  }
}
</code></pre>
<p>This is a violation of the <strong>ISP</strong> (Interface Segregation Principle) because not every animal can make a sound. We are forcing the worm to implement this functionality while it does not have it.
A fix to that is splitting the interfaces up.</p>
<p>For example having an <code>Animal</code> that has behaviour that <strong>every</strong> animal needs to have, and then having an interface that extends <code>Animal</code> and provides sound functionality.</p>
<h2 id="dependency-inversion-principle-dip"><a class="header" href="#dependency-inversion-principle-dip">Dependency Inversion Principle (DIP)</a></h2>
<p>The last principle, the dependency inversion principle says that: &quot;High level modules should not depend on low level modules, both should depend on abstractions.&quot;
In other words, the hierarchy of our project should always point downwards.</p>
<p>A way to imagine this is having a <code>Game</code> class again:</p>
<pre><code class="language-java">class Game implements Runnable {
  private final Renderer&lt;Entity&gt; entityRenderer = new EntityRenderer&lt;&gt;(this);
  private final Renderer&lt;Tile&gt; tileRenderer = new TileRenderer&lt;&gt;(this);
  private final GameData data = new GameData(this);
  private final World world = new World();

  @Override public void run() {
    // create window, etc..
  }
}
</code></pre>
<p>The high level modules are <code>TileRenderer</code>, <code>EntityRenderer</code>, <code>GameData</code> here.
The low level module is the <code>Game</code> class.</p>
<p>All of those classes such as <code>EntityRenderer</code> depend on our low level module (<code>Game</code>). This is a violation of the <strong>DIP</strong> principle, since our high level modules should depend on abstractions and on what they need.</p>
<p>Say that the entity renderer needs a list of entities from a world:</p>
<pre><code class="language-java">class EntityRenderer implements Renderer&lt;Entity&gt; {
  private final Game game;
  EntityRenderer(Game game) { this.game = game; }

  @Override public void render(Screen screen, Entity entity) {
     final List&lt;Entity&gt; entities = game.world.entities;
  }
}
</code></pre>
<p>This is the current way which violates the principle. A fixed version of that would be:</p>
<pre><code class="language-java">class EntityRenderer implements Renderer&lt;Entity&gt; {
  private final List&lt;Entity&gt; entities;
  EntityRenderer(List&lt;Entity&gt; entities) { this.entities = entities; }

  @Override public void render(Screen screen, Entity entity) {
  }
}
</code></pre>
<p>We now have met all the requirements. <strong>SOLID</strong> is very important for object oriented programming and leads to better design and better software overall. Also, things such as testability and maintanability become much easier with <strong>SOLID</strong>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="anonymous-classes"><a class="header" href="#anonymous-classes">Anonymous Classes</a></h1>
<p>Anonymous class is a class that does not have name and is declared and instantiated in the same place.</p>
<p>When we are working with simple interfaces that contain just one or two methods, sometimes it may be better to make an implementation where it's needed (usually recommended with a <strong>lambda</strong>) rather than making a new class in our project.</p>
<p>One thing about interfaces is that we <strong>cannot instantiate them directly</strong>, but with anonymous classes, we can also make an implementation using this concept.</p>
<p>An example would be a <code>Runnable</code> interface, which is the most common interface that is contained in the JDK from the very first version, for running code on different threads (the <code>Thread</code> class):</p>
<pre><code class="language-java">interface Runnable {
  void run();
}
</code></pre>
<p>The interface looks like this, essentially making it a <strong>functional interface</strong>.
Functional interfaces are interfaces that <strong>contain just one abstract method</strong>, not more. Static methods or default methods don't matter.</p>
<p>There are two ways we can make an implementation of this interface right now.</p>
<h2 id="anonymous-class"><a class="header" href="#anonymous-class">Anonymous class</a></h2>
<pre><code class="language-java">Runnable action = new Runnable() {
  @Override public void run() {
 
  }
};
</code></pre>
<p>This is the syntax of an anonymous class (it can contain more methods).
Now we can add some code into the <code>run</code> method and run the runnable and see the result.</p>
<pre><code class="language-java">Runnable action = new Runnable() {
  @Override public void run() {
    System.out.println(&quot;Text&quot;);
  }
};
action.run();
</code></pre>
<p>This is superior to making an entire class in our project just for that one method. <strong>Lambda expressions</strong> even help us more in this.</p>
<p>However, there are a lot of vulnerabilities and downsides we will talk about.</p>
<h2 id="regular-class"><a class="header" href="#regular-class">Regular Class</a></h2>
<p>The implementation with a regular class would look like:</p>
<pre><code class="language-java">class Action implements Runnable {
  @Override public void run() {
    System.out.println(&quot;Text&quot;);
  }
}
</code></pre>
<p>Then in code:</p>
<pre><code class="language-java">final Runnable action = new Action();
action.run();
</code></pre>
<h2 id="lambda-expressions"><a class="header" href="#lambda-expressions">Lambda Expressions</a></h2>
<p>And finally, the third way is using a lambda expression:</p>
<pre><code class="language-java">final Runnable action = () -&gt; System.out.println(&quot;Text&quot;);
action.run();
</code></pre>
<p>We will cover lamba expressions in more depth later.</p>
<h2 id="effectively-final-variables"><a class="header" href="#effectively-final-variables">Effectively Final Variables</a></h2>
<p>Anonymous classes can't have static members as they are anonymous.
We can still however declare instance fields and methods inside the implementation.</p>
<p>With anonymous classes, we are introducing a new concept, called <strong>Effectively final &amp; final variables</strong>. 
We have met with final variables before. </p>
<p>Effectively final variables are any variables that have their reference/value assigned only <strong>once</strong>. If we mutate that variable somewhere else, it's not effectively final anymore.
We should only be worried about effectively final variables which are <strong>local</strong> however.</p>
<p>Effectively final or final <strong>local</strong> variables are a requirement if we want to access those from the outer scope.
Fields from the enclosing class can be accessed or mutated normally.
Variables inside anonymous class <strong>are</strong> captured, however we want to prevent mutation from inside the anonymous class to not introduce problems we will talk about later.</p>
<p>An example of effectively final variables:</p>
<pre><code class="language-java">int foo = 1; // foo is effectively final
</code></pre>
<pre><code class="language-java">int foo = 1; // foo is effectively final
foo = 2; // foo is no longer effectively final
</code></pre>
<p>This applies to both reference types and primitive types.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h1>
<p>An abstract class is similar to an interface, with one big difference.
Abstract class has state and behaviour, just like normal classes do, while interfaces only have behaviour (because interfaces can't have instance 
fields).</p>
<p>we can think of <code>Runnable</code> being an abstract class.</p>
<pre><code class="language-java">abstract class Runnable {
  abstract void run();
}
</code></pre>
<p>There is a new keyword, <code>abstract</code>, which we use when declaring abstract members (we can declare abstract methods and classes)
In interfaces, this keyword is reduntant as all methods without a body are abstract there.</p>
<p>An abstract class requires an implementation and cannot be instantiated directly, just like an interface.
There are two ways to solve that.</p>
<ul>
<li>Anonymous classes</li>
<li>Regular implementations</li>
</ul>
<p>We cannot use lambda expressions, because abstract classes can hide it's state, while interface cannot.</p>
<p>The syntax is just about the same when creating an implementation. (Except we use <code>extends</code> when extending, as <code>Runnable</code> is a class.)</p>
<pre><code class="language-java">class Action extends Runnable {
  @Override public void run() {

  }
}
</code></pre>
<p>Abstract classes can be good when we require mutability (such as an <code>Entity</code> class that has a mutable field <code>health</code>).</p>
<p>Note that abstract classes can extend abstract classes just like interfaces can extend interfaces, however the next non-abstract subtype needs to implement everything that is abstract.</p>
<p>We will talk about mutability and immutability more later.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="lambda-expressions-1"><a class="header" href="#lambda-expressions-1">Lambda Expressions</a></h1>
<p>Lambda expressions are a shorthand for functional interfaces (which are those with only one abstract method). Think of the interface <code>Runnable</code>. Let's have this simple method:</p>
<pre><code class="language-java">void foo(int bar, Runnable runnable) {
  if (bar &lt;= 0) {
    runnable.run(); return;
  }

  System.out.println(bar);
}
</code></pre>
<p>We would once again have three ways of calling this method (it's an interface). 
One way would be having a regular implementation as a class:</p>
<pre><code class="language-java">class Action implements Runnable {
  @Override public void run() {
    System.err.println(&quot;Invalid parameter&quot;);
  }
}
</code></pre>
<p>And then calling:</p>
<pre><code class="language-java">foo(-1, new Action());
</code></pre>
<p>The second way would be an anonymous class:</p>
<pre><code class="language-java">foo(-1, new Runnable() {
   @Override public void run() {
    System.err.println(&quot;Invalid parameter&quot;);
   }
});
</code></pre>
<p>And the third way would be using a lambda expressions, which is allowed here since the interface is a functional interface.</p>
<pre><code class="language-java">foo(-1, () -&gt; System.err.println(&quot;Invalid parameter&quot;));
</code></pre>
<p>There are advantages of a lambda expression over an anonymous class, such as that the lambda object can be pooled and reused while the class can not.</p>
<p>The syntaxes are the following:</p>
<ul>
<li><code>() -&gt;</code> ( for method that accepts no parameters ) (such as <code>Runnable</code>)</li>
<li><code>foo -&gt;</code> ( for method that accepts a single parameter ) (such as a<code> Consumer&lt;T&gt;</code>)</li>
<li><code>(foo, bar)</code> -&gt; (for method that accepts two or more parameters (such as a <code>BiConsumer&lt;T, U&gt;</code> or a <code>BiFunction&lt;T, U, R&gt;</code>)</li>
</ul>
<p>A lambda expression can also have a body, but then there are differences from a regular lambda expression.</p>
<p>A lambda expression without a body can not contain more than <strong>one</strong> command.
When returning, we do not use the <code>return</code> keyword since the expression does that for us.</p>
<p>See a <code>Supplier&lt;T&gt;</code> interface example, where we return an <code>int</code>.</p>
<pre><code class="language-java">void foo(Supplier&lt;Integer&gt; supplier) {
  System.out.println(supplier.get());
}
</code></pre>
<p>Without a body:</p>
<pre><code class="language-java">foo(() -&gt; 5);
</code></pre>
<p>With a body:</p>
<pre><code class="language-java">foo(() -&gt; {
  return 5;
});
</code></pre>
<p>With lambda expressions, there is also a new concept called <strong>generics</strong>.
We will however talk about method references in the next chapter.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="method-references"><a class="header" href="#method-references">Method References</a></h1>
<p>Method references are a shortened way for writing lambda expressions in java.</p>
<p>There are four types of method references:</p>
<ul>
<li>Constructor</li>
<li>Instance method</li>
<li>Static method</li>
<li>Instance method of an arbitrary object </li>
</ul>
<h2 id="constructor-method-references"><a class="header" href="#constructor-method-references">Constructor Method References</a></h2>
<p>Constructor method references are pretty simple. Say that we have an interface which returns an <code>Object</code>:</p>
<pre><code class="language-java">interface Foo {
  Object bar();
}
</code></pre>
<p>We could now write a declaration of this <code>Foo</code> interface as a lambda expression as we have previously learned, or as constructor a method reference.
The <code>Object</code> class has 1 empty constructor, so using a lambda expression would look like:</p>
<pre><code class="language-java">Foo foo = () -&gt; new Object();
</code></pre>
<p>Method references exist just to simplify this. If the constructor takes no parameters, we can use a constructor reference here:</p>
<pre><code class="language-java">Foo foo = Object::new;
</code></pre>
<h2 id="instance-method"><a class="header" href="#instance-method">Instance Method</a></h2>
<p>The second type of method reference, the instance method is a reference to an instance method which takes the same parameters as from the lambda expression.</p>
<p>If we are passing the entries of a <code>HashMap</code> to an instance method of our class, we can use it's <code>forEach</code> function that takes a <code>BiConsumer&lt;K, V&gt;</code>.</p>
<pre><code class="language-java">void foo(Map&lt;String, String&gt; bar) {
  bar.forEach((key, value) -&gt; bar(key, value));
}

void bar(String key, String value) {
 System.out.printf(&quot;Key: %s, Value: %s%n&quot;, key, value); 
}
</code></pre>
<p>This is the way using a lambda expression.</p>
<p>We can use an instance method here:</p>
<pre><code class="language-java">void foo(Map&lt;String, String&gt; bar) {
  bar.forEach(this::bar);
}

void bar(String key, String value) {
 System.out.printf(&quot;Key: %s, Value: %s%n&quot;, key, value); 
}
</code></pre>
<p>Since we are are calling the instance method <code>bar</code> from an instance method, we are allowed to use the <code>this</code> keyword to call the <code>bar</code> method.</p>
<h2 id="static-methods"><a class="header" href="#static-methods">Static Methods</a></h2>
<p>Static methods are used just like instance methods, but the method we are calling needs to be static.
For example, printing out the contents of an <code>ArrayList</code>.
Lambda version:</p>
<pre><code class="language-java">void foo(List&lt;String&gt; bar) {
  bar.forEach(s -&gt; System.out.println(s));
}
</code></pre>
<p>Method reference version:</p>
<pre><code class="language-java">void foo(List&lt;String&gt; bar) {
  bar.forEach(System.out::println);
}
</code></pre>
<h2 id="instance-methods-of-an-arbitary-object"><a class="header" href="#instance-methods-of-an-arbitary-object">Instance Methods of an Arbitary Object</a></h2>
<p>Instance methods of an arbitrary objects look like have the same syntax as static methods, but they use the first supplied parameter to access the method we are calling (instance method)</p>
<pre><code class="language-java">interface Foo {
  void bar(String string, Bar bar);
}

interface Bar {
  void foo(String string);
}
</code></pre>
<p>When using a lambda expression:</p>
<pre><code class="language-java">void bar(Foo foo, Bar bar) {
  foo.bar(&quot;Foo&quot;, bar);
}

void foo() {
  bar((string, bar) -&gt; bar.foo(string), string -&gt; System.out.println(string));
}
</code></pre>
<p>Can be replaced with the last type of a method reference:</p>
<pre><code class="language-java">void bar(Foo foo, Bar bar) {
  foo.bar(&quot;Foo&quot;, bar);
}

void foo() {
  bar(Bar::foo, System.out::println);
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mutability-and-immutability"><a class="header" href="#mutability-and-immutability">Mutability and Immutability</a></h1>
<p>Immutability and mutability are pretty straightforward concepts, but they might be hard to understand at first.</p>
<p>We have discussed state and behaviour before when describing <strong>OOP (Object Oriented Programming)</strong>*. When saying state, we mean the properties of an object. Imagine the old <code>Car</code> object we had. The fields <code>make</code> and <code>speed</code> were the state of that object. However note that state only exists when we are speaking of objects, not classes. </p>
<p>Behaviour on the other hand are the functions of an object.</p>
<h2 id="immutable-object"><a class="header" href="#immutable-object">Immutable object</a></h2>
<p>An immutable object is an object which's <em>state</em>  <strong>cannot</strong> be changed after it's constructed (or instantiated). 
Perfect examples of immutable objects are the <code>String</code> objects.</p>
<p>So till we cannot change the state of an object, it's considered immutable.
An easy way to achieve that is using the <code>final</code> keyword, which guarantees that we cannot change a reference/value of a field.</p>
<p>The <code>Car</code> example is an example of an immutable object too:</p>
<pre><code class="language-java">class Car {
  final String make;
  final float maxSpeed;

  Car(String make, float maxSpeed) {
   this.make = make;
   this.maxSpeed = maxSpeed;
  }
}
</code></pre>
<p>We cannot really manipulate the car object once we have constructed it, so it's immutable.
However final doesn't always mean immutable. When we have an object that is mutable, but is declared as final, it doesn't change anything.
The object still remains mutable.</p>
<p>So mutability really means that we can change the state of an object, whilst immutability means we cannot.</p>
<p>This sometimes leads to better design and is especially useful when multithreading. When we multithread, we sometimes use the <code>volatile</code> keyword or the atomic classes that the JDK provides. This is because when we change a variable value/reference, the threads need to be notified that there has been a change made. This is called thread visibility and the <code>volatile</code> keyword fixes this.
Howeverm when we are working with immutable objects, we don't need to be worried about our fields being volatile, because they do not change reference/value at all.</p>
<p>Mutable objects are good and sometimes a better option, but you need to be careful, especially when overriding the Object's <code>hashCode</code> and <code>equals</code> method that could potentially produce a different hash depending on the state. This is dangerous when working with collections such as a <code>HashMap</code> or an <code>ArrayList</code> where those methods are called.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="streams"><a class="header" href="#streams">Streams</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="garbage-collector-and-statics"><a class="header" href="#garbage-collector-and-statics">Garbage Collector and Statics</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="using-apis"><a class="header" href="#using-apis">Using APIs</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="time-apis"><a class="header" href="#time-apis">Time APIs</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="java-io"><a class="header" href="#java-io">Java IO</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="java-nio"><a class="header" href="#java-nio">Java NIO</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
